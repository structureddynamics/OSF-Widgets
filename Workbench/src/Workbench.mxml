<?xml version="1.0" encoding="utf-8"?>
<mx:Application xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:axiis="http://www.axiis.org/2009"
  xmlns:degrafa="http://www.degrafa.com/2007" xmlns:charts="org.axiis.charts.*"
  xmlns:geometry="com.degrafa.geometry.*" xmlns:components="com.sd.semantic.components.*"
  xmlns:toolbox="com.flextoolbox.controls.*" layout="absolute"
  creationComplete="init()" xmlns:panel="com.visualempathy.extensions.panel.*">
  <mx:Script>
    <![CDATA[
    import com.esria.samples.dashboard.managers.PodLayoutManager;
    import com.esria.samples.dashboard.managers.StateManager;
    import com.esria.samples.dashboard.view.Pod;
    import com.sd.semantic.core.*;
    import com.sd.semantic.events.SchemaLoadedEvent;
    import com.sd.semantic.events.SemanticComponentItemEvent;
    import com.sd.semantic.settings.GeneralSettings;
    import com.sd.semantic.utilities.SemanticUtils;
    import com.visualempathy.extensions.panel.SuperPanelPlus;
    
    import events.IndicatorEvent;
    
    import flash.utils.describeType;
    import flash.utils.getQualifiedClassName;
    import flash.xml.XMLDocument;
    
    import mx.collections.ArrayCollection;
    import mx.collections.XMLListCollection;
    import mx.containers.TitleWindow;
    import mx.controls.Alert;
    import mx.controls.Text;
    import mx.controls.dataGridClasses.DataGridColumn;
    import mx.core.Application;
    import mx.events.DragEvent;
    import mx.events.ListEvent;
    import mx.events.MenuEvent;
    import mx.events.ModuleEvent;
    import mx.events.StyleEvent;
    import mx.managers.DragManager;
    import mx.managers.PopUpManager;
    import mx.managers.SystemManager;
    import mx.modules.IModuleInfo;
    import mx.modules.ModuleManager;
    import mx.rpc.events.FaultEvent;
    import mx.rpc.events.ResultEvent;
    import mx.rpc.http.HTTPService;
    import mx.utils.ObjectUtil;
    
    import org.sunlightlabs.ClearMaps.FeatureEvent;
    
    import settings.*;
    
    public var info:IModuleInfo;		
      
    /** Workbench settings */
    public var workbenchSettings:WorkbenchSettings;

    /** General settings */
    private var generalSettings:GeneralSettings;

    /** Internal ontological structure of the semantic component application */
    public var schema:Schema = new Schema();

    /** Defined namespaces of the application */
    public var namespaces:Namespaces = new Namespaces();

    /** FlashVars used to communite data to the semantic component application */

    /** Used to specify a specific URL where component settings files can be found */
    [Bindable]public var baseAppUrl:String = "";

    /** Reference to one or multiple target schemas URLs */
    [Bindable]public var inputSchemas:String = "";

    /** 
     * Specifies a folder path where the settings file for this instance can be found
     * at the baseAppUrl. 
     */
    [Bindable]public var settingsFolder:String = "settings/";
      
    /** Number of schemas that are supposed to be loaded by the workbench */
    private var schemaToLoad:int = 0;

    /** Number of schemas loaded (so far) by the workbench) */
    private var schemaLoaded:int = 0;

    /** Titles of the datasets loaded by the workbench */
    private var datasetsTitles:Array = [];

    /** Resultset of subjects generated by the Filtering component of the workbench */
    public var filteringResultset:Resultset = null;

    /** Resultset of subjects generated by selection clicks in different components of the workbench */
    public var selectionsResultset:Resultset = null;

    /** A reference to the file of the loaded session */
    public var loadedSessionFile:String = "";

    /**
     * Resultset of subjects that have been tagged as "sticky", which means that they have to always be
     * present in the workbench, whatever the action performed by the user.
     */
    public var stickyResultset:Resultset = null;

    /** List of all filted datasets used to filters the records to display in the records selector panel */
    private var filteredDatasets:Array = [];

    /** List of all filted types used to filters the records to display in the records selector panel */
    private var filteredKinds:Array = [];

    /** List of all filted attributes used to filters the records to display in the records selector panel */
    private var filteredAttributes:Array = new Array();

    /** List of all datasets that can be used, for this session, as a filtering criteria */
    private var allDatasets:Array = [];

    /** List of all types that can be used, for this session, as a filtering criteria */
    private var allKinds:Array = [];

    /** List of all attributes that can be used, for this session, as a filtering criteria */
    private var allAttributes:Array = [];

    /**
    * Binds the records URI of different resultsets to rows ID in the datagrid component.
    * 
    * The structure of this array is: recordsUriById[row_id] = record.uri
    */
    public var recordsUriById:Array = [];

    /**
     * Keep track of the selected indicators in the datagrid component.
     * 
     * This structure is populated in the RecordsSelectorHeaderRenderer.as file.
     * 
     * The structure of this array is: selectedIndicators[...] = attribute-uri
     * 
     * @default Array() 
     */
    public var selectedIndicators:Array = [];

    /** List of all the non-indicator attributes used to create a dashboard window */
    public var selectedNonIndicators:Array = [];

    /**
    * Array of objects that have been created, but that have been hidden by a "close" icon clik.
    * Items of this list are used to populate the "view" menu item
    * 
    * Objects are of kind: {label: "", id: ""}
    */
    public var viewControls:Array /* of panel ID */ = [];

    /** Selection mode to interact with records from the records list. Two modes: (1) 'selection', (2) 'drag' */
    private var selectionMode:String = "selection";

    /** Base URL of the flex component */
    private var baseUrl:String = "./";
    
    /** Base URL of the flex component */
    private var settingsUrl:String = "./settings/"; 
      
    /** Dashboard component */
    public var dashboard:DisplayObject;
      
    /** 
    * List of initially selected attributes. These attributes are used to initialize the
    * Workbench session. This is used to limit the number of columns in the records selector
    * window.
    */
    public var includeAttributesList:Array = [];
      
    var columnsColors:Array = [0xFFF7977A, 0xFFF9AD81, 0xFFFDC68A, 0xFFFFF79A, 0xFFC4DF9B, 0xFFA2D39C, 0xFF82CA9D, 0xFF7BCDC8, 0xFF6ECFF6, 0xFF7EA7D8, 0xFF8493CA, 0xFF8882BE, 0xFFA187BE, 0xFFBC8DBF, 0xFFF49AC2, 0xFFF6989D, 0xFFF7977A, 0xFFF9AD81, 0xFFFDC68A, 0xFFFFF79A, 0xFFC4DF9B, 0xFFA2D39C, 0xFF82CA9D, 0xFF7BCDC8, 0xFF6ECFF6, 0xFF7EA7D8, 0xFF8493CA, 0xFF8882BE, 0xFFA187BE, 0xFFBC8DBF, 0xFFF49AC2, 0xFFF6989D, 0xFFF7977A, 0xFFF9AD81, 0xFFFDC68A, 0xFFFFF79A, 0xFFC4DF9B, 0xFFA2D39C, 0xFF82CA9D, 0xFF7BCDC8, 0xFF6ECFF6, 0xFF7EA7D8, 0xFF8493CA, 0xFF8882BE, 0xFFA187BE, 0xFFBC8DBF, 0xFFF49AC2, 0xFFF6989D];      
      
      
      
    /** Initialization of the Workbench */
    private function init():void
    {
      /** Make sure that the SuperPanelPlus controls are propery positionned */
      filteringPanel.positionChildren();
      recordsSelectorPanel.positionChildren();

      if(Application.application.parameters.baseAppUrl)
      {
        baseAppUrl = Application.application.parameters.baseAppUrl;
      }

      if(Application.application.parameters.inputSchemas)
      {
        inputSchemas = Application.application.parameters.inputSchemas;
      }
      
      if(Application.application.parameters.settingsFolder)
      {
        settingsFolder = Application.application.parameters.settingsFolder;
      }      

      /** 
      * Initialize the non-Indicator component structure used to update records when
      * a user interacts with all components.
      */
      selectedNonIndicators.push("stickyComparisonChart");

      /**
      * Initialize the ontological structure used to describe records manipulated by
      * this semantic component application
      *  
      * Two sources can be exploited:
      *   (1) local schema file(s)
      *   (2) remote schema file(s)
      */

      /** Load all local schema files needed by this semantic application */
      if(inputSchemas != "")
      {
        var schemas:Array = inputSchemas.split(";");

        schemaToLoad = schemas.length;

        for each(var schemaUrl:String in schemas)
        {
          schema.loadSchema(schemaUrl);
          schema.addEventListener(SchemaLoadedEvent.SCHEMA_LOADED, schemaLoadedHandler);
        }
      }
    }

    /** Event handler when a schema finished to be loaded in the Workbench */
    private function schemaLoadedHandler(event:SchemaLoadedEvent):void
    {
      if(event.type == "schemaLoaded")
      {
        this.schemaLoaded++;

        if(this.schemaToLoad == this.schemaLoaded)
        {
          /** All schemas have been loaded, lets continue to other processing of this application */

          /**
          * Load settings
          *  
          * Check if the application that embede this semantic component defined its 
          * baseAppUrl. If it didn't, we simply use the default local location "./".
          */
          
          if(Application.application.baseAppUrl && Application.application.baseAppUrl != "")
          {
            baseUrl = Application.application.baseAppUrl;
          }
          
          if(Application.application.settingsFolder && Application.application.settingsFolder != "")
          {
            settingsUrl = baseUrl + settingsFolder;
          }          

          var settingsLoader:URLLoader = new URLLoader();
          settingsLoader.load(new URLRequest(settingsUrl + "General.xml"));
          settingsLoader.addEventListener(Event.COMPLETE, processGeneralSettingsHandler);
        }
      }
    }

    /** Processing general settings handler */
    private function processGeneralSettingsHandler(event:Event):void
    {
      var isError:Boolean = false;

      try
      {
        generalSettings = new GeneralSettings(new XML(event.target.data));
      }
      catch(error:Error)
      {
        Alert.show("Can't load settings file '/settings/General.xml'. The workbench tool won't be displayed.");
        isError = true;
      }

      if(!isError)
      {
        if(generalSettings.error == true)
        {
          Alert.show(
            "Required settings are missing in the settings file '/settings/General.xml'. The workbench tool won't be displayed.");
          isError = true;
        }
      }

      if(!isError)
      {
        /** Load the theme if a theme has to be loaded for this application */
        if(generalSettings.theme != "")
        {
          StyleManager.loadStyleDeclarations(baseUrl + generalSettings.theme, true);
        }

        var settingsLoader:URLLoader = new URLLoader();
        settingsLoader.load(new URLRequest(settingsUrl + "Workbench.xml"));
        settingsLoader.addEventListener(Event.COMPLETE, processWorkbenchSettingsHandler);
      }

      this.removeEventListener(Event.COMPLETE, processGeneralSettingsHandler);
    }

    /** Get the workbench settings files from the internet */
    private function processWorkbenchSettingsHandler(event:Event):void
    {
      var isError:Boolean = false;

      try
      {
        workbenchSettings = new WorkbenchSettings(new XML(event.target.data));
      }
      catch(error:Error)
      {
        Alert.show("Can't load settings file '/settings/Workbench.xml'. The workbench tool won't be displayed.");
        isError = true;
      }

      if(!isError)
      {
        if(workbenchSettings.error == true)
        {
          Alert.show(
            "Required settings are missing in the settings file '/settings/Workbench.xml'. The workbench tool won't be displayed.");
          isError = true;
        }
      }

      if(!isError)
      {
        /** Create the Dashboard module */
        info = ModuleManager.getModule(baseUrl + "sDashboard.swf");
        info.addEventListener(ModuleEvent.READY, modDashboardReadyHandler);
          
        info.load();              
      }

      this.removeEventListener(Event.COMPLETE, processWorkbenchSettingsHandler);
    }
      
    private function modDashboardReadyHandler(e:ModuleEvent):void 
    {
      dashboard = info.factory.create() as DisplayObject;
      
      dashboard.baseUrl = this.baseUrl;
      
      dashboardPanel.addChild(dashboard);
      
      /** Properly position the minimize, maximaze and resize buttons on the SuperPanel */
      dashboardPanel.positionChildren();
      
      /** Create the initial tab */
      dashboard.addTab("Main");       
  
      /** 
      * Display the tile window that asks to pre-select a series of indicators to use 
      * initially for the Workbench
      */ 
      var selectIndicatorsTileWindow:SelectIndicatorsTileWindow =
        SelectIndicatorsTileWindow(PopUpManager.createPopUp(this, SelectIndicatorsTileWindow, true));
    }
      
    public function getInitialRecords():void
    {
      /** Start the application */
      
      /** attribute filters */
      var attributeFilters:String = "all";
      
      /** dataset filters */
      var datasetFilters:String = "";
      
      if(workbenchSettings.filterDatasets.length > 0)
      {
        var i:int = 0;
        
        for each(var filter:String in workbenchSettings.filterDatasets)
        {
          if(i > 0)
          {
            datasetFilters += (";" + filter);
          }
          else
          {
            datasetFilters += filter;
          }
          
          i++;
        }
      }
      else
      {
        datasetFilters = "all";
      }
      
      /** type filters */
      var typeFilters:String = "all";
      
      /** Get the description of the sticky records */
      getStickyRecordsDescription(workbenchSettings.stickyRecords);
      
      /** Get the initial state of the structWSF data */
      
      var requestParameters:Object = {
        attributes: attributeFilters, 
        types: typeFilters, 
        datasets: datasetFilters, 
        items: "300",
        page: "0", 
        include_aggregates:"true", 
        include_attributes_list: includeAttributesList.join(";")
      };
      
      var httpService:HTTPService = new HTTPService();
      
      httpService.url = workbenchSettings.structWSFBaseURL + "/search/";
      httpService.method = "POST";
      httpService.headers['Accept'] = 'text/xml;q=1';
      httpService.showBusyCursor = true;
      httpService.resultFormat = "e4x";
      httpService.addEventListener(ResultEvent.RESULT, filterResultsetHandler);
      httpService.addEventListener(FaultEvent.FAULT, filterResultsetFaultHandler);
      
      httpService.send(requestParameters);         
    }

    /** Browse structWSF event handler */
    private function filterResultsetHandler(event:ResultEvent):void
    {
      /** Check if there is any load/parsing error */
      var isError:Boolean = false;

      try
      {
        filteringResultset = new Resultset(event.result);
      }
      catch(error:Error)
      {
        Alert.show("Error reading the resultset");
        isError = true;
      }

      if(!isError)
      {
        /** display available datasets */

        /** Check if we have a local copy of the names of the datasets defined on the target structWSF instance */

        var so:SharedObject = SharedObject.getLocal("sd_Workbench");

        if(so.data.datasets)
        {
          datasetsTitles = so.data.datasets
          displayDatasets();
        }
        else
        {
          getDatasetsTitles();
        }

        /** refresh the records selection datagrid */
        refreshRecordsSelector();
      }
    }

    /**
    * It refreshes the list of records in the DatGrid records slector component. It takes the different resultsets
    * of the workbench (filterig, selections, search, etc), and refresh (recreate) the list of records.
    * 
    * @param recordsToSelect Array of subjects to select while refreshing the datagrid.
    * 
    * @return Returns nothing
    */
    private function refreshRecordsSelector(subjectsToSelect:Array = null):void
    {
      /**
      * The first step is to get all non-Aggregate records from the different resultsets:
      *   (1) filtering
      *   (2) selections
      *   (3) search
      */

      /** List of all records to be displayed/manipulated */
      var records:ArrayCollection = new ArrayCollection();

      /**
      * Get all record types from all resultsets
      */
      var recordsTypes:Array = [];

      if(filteringResultset != null)
      {
        recordsTypes = recordsTypes.concat(filteringResultset.getSubjectTypes());
      }

      if(selectionsResultset != null)
      {
        recordsTypes = recordsTypes.concat(selectionsResultset.getSubjectTypes());
      }

      /** remove possible duplicates */
      recordsTypes = recordsTypes.filter(function(e:*, i:int, a:Array):Boolean
      {
        return a.indexOf(e) == i;
      })
        
      if(recordsTypes.length == 0)
      {
        return;
      }

      /** List of all attributes used to create columns in the datagrid */
      var recordsAttributes:Array = [];

      /** Get all unique attributes of all non-Aggregate types */
      for each(var recordType:String in recordsTypes)
      {
        if(recordType != "aggr_Aggregate" && recordType != namespaces.getVariable("aggr_Aggregate")
          && recordType != namespaces.getNamespace("aggr_Aggregate"))
        {
          /**
          * Only keep the records that are non-Aggregate records
          */
          var recordsType:Array = [];

          if(filteringResultset != null)
          {
            recordsType = recordsType.concat(filteringResultset.getSubjectsByType(recordType));
          }

          if(selectionsResultset != null)
          {
            recordsType = recordsType.concat(selectionsResultset.getSubjectsByType(recordType));
          }

          /** remove possible duplicates */
          recordsType = recordsType.filter(function(e:*, i:int, a:Array):Boolean
          {
            return a.indexOf(e) == i;
          })

          var attributesDump:Array = [];

          if(filteringResultset != null)
          {
            attributesDump = attributesDump.concat(filteringResultset.getSubjectAttributes(recordsType));
          }

          if(selectionsResultset != null)
          {
            attributesDump = attributesDump.concat(selectionsResultset.getSubjectAttributes(recordsType));
          }

          /** remove possible duplicates */
          attributesDump = attributesDump.filter(function(e:*, i:int, a:Array):Boolean
          {
            return a.indexOf(e) == i;
          })

          /**
          * Create the list of unique attributes used to describe records of all resultsets
          */
          for each(var ad:String in attributesDump)
          {
            if(recordsAttributes.indexOf(ad) == -1)
            {
              recordsAttributes.push(ad);
            }
          }
        }
      }

      /**
      * Now populate the records structure to be displayed in the dataGrid
      */

      /** Re-initialize the recordsUriById structure because it will get re-populated */
      recordsUriById = [];

      /** Record currently being processed */
      var currentRecordID:int = 0;

      /** Description that goes with the name of the attribute/column */
      var attributeNamesDescription:Array = [];
      
      /** Array with the ordered columns to created in the DataGrid */
      var orderedColumnsClusters:Array = [];
      var createdAttributes:Array = [];

      for each(recordType in recordsTypes)
      {
        if(recordType != "aggr_Aggregate" && recordType != namespaces.getVariable("aggr_Aggregate")
          && recordType != namespaces.getNamespace("aggr_Aggregate"))
        {
          recordsType = [];

          if(filteringResultset != null)
          {
            recordsType = recordsType.concat(filteringResultset.getSubjectsByType(recordType));
          }

          if(selectionsResultset != null)
          {
            recordsType = recordsType.concat(selectionsResultset.getSubjectsByType(recordType));
          }

          /** remove possible duplicates */
          recordsType = recordsType.filter(function(e:*, i:int, a:Array):Boolean
          {
            return a.indexOf(e) == i;
          })

          attributesDump = [];

          if(filteringResultset != null)
          {
            attributesDump = attributesDump.concat(filteringResultset.getSubjectAttributes(recordsType));
          }

          if(selectionsResultset != null)
          {
            attributesDump = attributesDump.concat(selectionsResultset.getSubjectAttributes(recordsType));
          }

          /** remove possible duplicates */
          attributesDump = attributesDump.filter(function(e:*, i:int, a:Array):Boolean
          {
            return a.indexOf(e) == i;
          })


          /** Create the datagrid columns array */
          for each(var record:Subject in recordsType)
          {
            /** record element of the datagrid data array */
            var rec:Object = {};

            /**
            * First we create the data for the two main columns:
            *   (1) The "id" column, with a recordset ID used mainly for local referencing & sorting
            *   (2) The "record" column, with the prefLabel of the record
            *   (3) The "kind" column, with the kind of the record (used for sorting purposes)
            * 
            * These three columns are static, and are the minimal columns to be displayed.
            */
            currentRecordID++;

            rec["id"] = currentRecordID;

            /** Bind the row ID with the record URI */
            recordsUriById[currentRecordID] = record.uri;

            /** Get the preferred label of the record to be displayed in the "record" column */
            rec["record"] = record.getPrefLabel(generalSettings.prefLabelAttributes);

            /** Get the name of the type of the record */

            /** Check if the type is defined in the schema structure. If it is, we try to get a prefLabel for it.*/

            var recordTypeName:String = "";

            var type:SchemaType = schema.getType(record.type);

            if(type != null)
            {
              if(type.prefLabel != "")
              {
                recordTypeName = type.prefLabel;
              }
            }

            /**
            * If we can't find a prefLabel for this type in the schema structure, we get it
            * directly by manipulating the URI of the type.
            */
            if(recordTypeName == "")
            {
              recordTypeName = namespaces.getNamespace(record.type);

              var end:int = 0;

              end = recordTypeName.lastIndexOf("#");

              if(end == -1)
              {
                end = recordTypeName.lastIndexOf("/");
              }

              if(end > 0)
              {
                recordTypeName = recordTypeName.substr(end + 1, (recordTypeName.length - end));
              }
            }

            rec["kind"] = recordTypeName;

            for each(var includeAttribute:String in includeAttributesList)
            {
              /** Try to get the description of the attribute in the schema structure */
              var values:Array = record.getPredicateValues(includeAttribute);
              var attr:SchemaAttribute = schema.getAttribute(includeAttribute);
              
              if(attr != null)
              {
                /** Get the name of the column to display */
                var columnName:String = "";
  
                columnName = attr.prefLabel
                  
                /**
                * If no preferred label is available for this attribute, we get it by manipulating the
                * URI of the attribute.
                */
                if(columnName == "")
                {
                  columnName = includeAttribute;

                  var fullURI = namespaces.getNamespace(includeAttribute);

                  var end:int = 0;

                  end = fullURI.lastIndexOf("#");

                  if(end == -1)
                  {
                    end = fullURI.lastIndexOf("/");
                  }

                  if(end > 0)
                  {
                    columnName = fullURI.substr(end + 1, (fullURI.length - end));
                  }
                }
                
                /** 
                * Check if the name of the attribute is already existing. If it does, it means
                * that two attributes share the same prefLabel. In that case, we add something
                * to it to distinct it from the other one
                */
                if(rec[columnName])
                {
                  var modfiedColumnName:String = includeAttribute;
                  
                  var fullURI = namespaces.getNamespace(includeAttribute);
                  
                  var end:int = 0;
                  
                  end = fullURI.lastIndexOf("#");
                  
                  if(end == -1)
                  {
                    end = fullURI.lastIndexOf("/");
                  }
                  
                  if(end > 0)
                  {
                    modfiedColumnName = fullURI.substr(end + 1, (fullURI.length - end));
                  }  
                  
                  columnName += " [" + modfiedColumnName + "]";
                }      
                
                attributeNamesDescription[columnName] = attr;
  
                /** We define the columns, and their order */    
                
                /** We cluster attributes that are comparable one between the others */   
                if(createdAttributes.indexOf(attr.uri) == -1)
                {
                  createdAttributes.push(attr.uri);
                  
                  if(!orderedColumnsClusters[0])
                  {
                    /** The first set is the one of the attributes which are not comparable with anything else */                  
                    orderedColumnsClusters = [{
                      comparableWith: [],
                      attributes: []
                    }];
                  }
                  
                  if(attr.comparableWith.length == 0)
                  {
                    /** Not comparable with anything */
                    orderedColumnsClusters[0]["attributes"].push({
                      "attribute": columnName,
                      "ordering": columnName
                    });
                  }
                  else
                  {
                    /** 
                    * Try to find a set where one of the comparable attribute can be found.
                    * If nothing can be found, then we create a new set
                    */
                    
                    var found:Boolean = false;
                    for(var clusterId = 0; clusterId < orderedColumnsClusters.length; clusterId++)
                    {
                      if(clusterId == 0)
                      {
                        continue;
                      }
                      
                      for(var i = 0; i < orderedColumnsClusters[clusterId].comparableWith.length; i++)
                      {
                        if(orderedColumnsClusters[clusterId].comparableWith[i] == attr.uri)
                        {
                          /** We found the cluster where to put that attribute that can be ordered */
                          orderedColumnsClusters[clusterId]["attributes"].push({
                            "attribute": columnName,
                            "ordering": attr.orderingValue
                          });
                          
                          found = true;
                          break;
                        }
                      }
                      
                      if(found)
                      {
                        break;
                      }
                    }
                    
                    if(!found)
                    {
                      /** Create a new cluster */
                      orderedColumnsClusters.push({
                        comparableWith: attr.comparableWith,
                        attributes: [{
                          "attribute": columnName,
                          "ordering": attr.orderingValue
                        }]
                      });
                    }
                  }
                }
                
//                if(attr.orderingValue != "")
//                {
//                  /**
//                   * If an ordering value is defined in the schema, then we use it to order the attributes.
//                   */
//                  orderedColumnsClusters[attr.comparableWith].push({
//                    "attribute": columnName,
//                    "ordering": attr.orderingValue
//                  });
//                }
//                else
//                {
//                  /**
//                   * If no ordering value is defined in the schema, then we use the attribute's name
//                   * as ordering value
//                   */
//                  orderedColumnsClusters[attr.comparableWith].push({
//                    "attribute": columnName,
//                    "ordering": columnName
//                  });                    
//                }
                
                
                /** We prepare the values to put in each column, for each row. */
                if(values.length > 0)
                {
                  /**
                  * @todo Right now, we are only displaying the first value that appears for an attribute.
                  * We should extend that so that we display a combobox, with all values, for 
                  * this given datagrid cell.
                  */
                  rec[columnName] = values[0].value;
                }
                else
                {
                  rec[columnName] = "";
                }                
              }
            }
            
//            /**
//            * For each unique records attributes, we create a column if they comply with some criterias (see below).
//            */
//            for each(var ra:String in recordsAttributes)
//            {
//              /** Try to get the description of the attribute in the schema structure */
//              var values:Array = record.getPredicateValues(ra);
//              var attr:SchemaAttribute = schema.getAttribute(ra);
//
//              /**
//              * Only display attributes that can be dispayed in Workbench tools. These
//              * attributes are:
//              *
//              * (1) The ones that have numberic allowedValue (a) Integer (b) Float (c) Boolean
//              * (2) The ones are have a supported display control
//              */
//              if(attr != null)
//              {
//                if(attr.allowedPrimitiveValues.indexOf("Integer") != -1 || 
//                   attr.allowedPrimitiveValues.indexOf("Float") != -1 || 
//                   attr.allowedPrimitiveValues.indexOf("Boolean") != -1 ||
//                   attr.displayControls.indexOf("sBarChart") != -1 ||
//                   attr.displayControls.indexOf("sLinearChart") != -1)
//                {
//                  /** Get the name of the column to display */
//                  var columnName:String = "";
//
//                  columnName = attr.prefLabel
//
//                  /**
//                  * If no preferred label is available for this attribute, we get it by manipulating the
//                  * URI of the attribute.
//                  */
//                  if(columnName == "")
//                  {
//                    columnName = ra;
//
//                    var fullURI = namespaces.getNamespace(ra);
//
//                    var end:int = 0;
//
//                    end = fullURI.lastIndexOf("#");
//
//                    if(end == -1)
//                    {
//                      end = fullURI.lastIndexOf("/");
//                    }
//
//                    if(end > 0)
//                    {
//                      columnName = fullURI.substr(end + 1, (fullURI.length - end));
//                    }
//                  }
//                  
//                  /** 
//                  * Check if the name of the attribute is already existing. If it does, it means
//                  * that two attributes share the same prefLabel. In that case, we add something
//                  * to it to distinct it from the other one
//                  */
//                  if(rec[columnName])
//                  {
//                    var modfiedColumnName:String = ra;
//                    
//                    var fullURI = namespaces.getNamespace(ra);
//                    
//                    var end:int = 0;
//                    
//                    end = fullURI.lastIndexOf("#");
//                    
//                    if(end == -1)
//                    {
//                      end = fullURI.lastIndexOf("/");
//                    }
//                    
//                    if(end > 0)
//                    {
//                      modfiedColumnName = fullURI.substr(end + 1, (fullURI.length - end));
//                    }  
//                    
//                    columnName += " [" + modfiedColumnName + "]";
//                  }
//
//                  attributeNamesDescription[columnName] = attr;
//
//                  if(values.length > 0)
//                  {
//                    /**
//                    * @todo Right now, we are only displaying the first value that appears for an attribute.
//                    * We should extend that so that we display a combobox, with all values, for 
//                    * this given datagrid cell.
//                    */
//                    rec[columnName] = values[0].value;
//                    rec.length++;
//                  }
//                  else
//                  {
//                    rec[columnName] = "";
//                    rec.length++;
//                  }
//                }
//              }
//            }

            records.addItem(rec);
          }
        }
      }

      /** The list of columns ordered for the data grid */
      var orderedColumns:Array = [];
            
      for(var clusterId = 0; clusterId < orderedColumnsClusters.length; clusterId++)
      {
        if(clusterId == 0)
        {
          /** Skip the cluster of un-clustered element; we will re-introduce them at the end of the columns */
          continue;
        }
        
        var columnColor = columnsColors[clusterId];
        
        orderedColumnsClusters[clusterId]["attributes"].sortOn("ordering");
        
        for(var attributeId = 0; attributeId < orderedColumnsClusters[clusterId]["attributes"].length; attributeId++)
        {
          orderedColumns.push({
            "attribute": orderedColumnsClusters[clusterId]["attributes"][attributeId]["attribute"],
            "columnColor": columnColor
          });
        }
      }
      
      var columnColor = columnsColors[clusterId+1];
      
      orderedColumnsClusters[0]["attributes"].sortOn("ordering");
      
      /** Now re-integrate the un-clustered attributes */
      for(var attributeId = 0; attributeId < orderedColumnsClusters[0]["attributes"].length; attributeId++)
      {
        orderedColumns.push({
          "attribute": orderedColumnsClusters[0]["attributes"][attributeId]["attribute"],
          "columnColor": columnColor
        });        
      }
      
      
      
      /**
      * Saves the selection list of the datagrid component.
      * It will be used to re-select possible selected elements after the refresh of the component.
      * The ID of the selected records is saved, otherwise we will loose the binding when we will recreate
      * the columns and rows bellow.
      */
      var selectedIndicesRecordId:Array = [];

      for each(var indice:String in recordsDataGrid.selectedIndices)
      {
        selectedIndicesRecordId.push(recordsDataGrid.dataProvider[indice].id);
      }

      /** Create all columns that will be used to manage records rows and populate the datagrid component. */
      if(records.length > 0)
      {
        /** Array defining all columns of the component */
        var columns:Array = [];

        /** Feed the datagrid with the records array structure defined above */
        recordsDataGrid.dataProvider = records;

        /**
         * First we create the data for the two main columns:
         *   (1) The "id" column, with a recordset ID used mainly for local referencing & sorting
         *   (2) The "record" column, with the prefLabel of the record
         *   (3) The "kind" column, with the kind of the record (used for sorting purposes)
         * 
         * These three columns are static, and are the minimal columns to be displayed.
         */

        var columnID:DataGridColumn = new DataGridColumn("id");
        columnID.setStyle("backgroundColor", "#F5F6CE");
        columnID.setStyle("color", "#000000");
        columns.push(columnID);

        var columnRecord:DataGridColumn = new DataGridColumn("record");
        columnRecord.showDataTips = true;
        columnRecord.setStyle("backgroundColor", "#CEE3F6");
        columnRecord.setStyle("color", "#000000");
        columns.push(columnRecord);

        var columnType:DataGridColumn = new DataGridColumn("kind");
        columnType.showDataTips = true;
        columnType.setStyle("backgroundColor", "#CEE3F6");
        columnType.setStyle("color", "#000000");
        columns.push(columnType);
        

        /** Now we iterate all coloumns that have been created to add checkboxes for each of them */
        for(var columnId:int = 0; columnId < orderedColumns.length; columnId++)
        {
          var columnName:String = orderedColumns[columnId]["attribute"];
          
          if(columnName != "record" && columnName != "kind" && columnName != "id")
          {
            /** Custom column generated from individual attribute of records populating the datagrid */
            var column:DataGridIndicatorColumn = new DataGridIndicatorColumn(columnName);

            column.setStyle("backgroundColor", "#"+orderedColumns[columnId]["columnColor"].toString(16));
            column.setStyle("color", "#000000");            
            
            var testText:TextField = new TextField();
            testText.text = columnName;
            column.width = testText.textWidth + 100;

            column.showDataTips = true;
            column.indicatorAttribute = attributeNamesDescription[columnName];

            var checkBoxItemRenderer:ClassFactory = new ClassFactory(RecordsSelectorHeaderRenderer);

            /** Check if the column is already selected (when loading a session) */
            if(attributeNamesDescription[columnName] && 
               selectedIndicators.indexOf(attributeNamesDescription[columnName].uri) != -1)
            {
              checkBoxItemRenderer.properties = {dataField: {isSelected: true}};
            }
            else
            {
              checkBoxItemRenderer.properties = {dataField: {isSelected: false}};
            }

            column.headerRenderer = checkBoxItemRenderer;

            columns.push(column);
          }
        }

        /** Create the columns */
        recordsDataGrid.columns = columns;
      }
      else
      {
        recordsDataGrid.columns = [];
      }

      /** Indice of datagrid rows to select */
      var selectedIndices:Array = [];

      /** Select additional subjects */
      if(subjectsToSelect != null && subjectsToSelect.length > 0)
      {
        for(var gridIndex:String in recordsDataGrid.dataProvider)
        {
          for each(var s:Subject in subjectsToSelect)
          {
            /** Check if the selected feature's record is in the datagrid list. */
            if(recordsUriById[recordsDataGrid.dataProvider[gridIndex].id] == s.uri)
            {
              selectedIndices.push(gridIndex);
            }
          }
        }
      }

      /** Re-populate the selectedIndices with the records that were previously selected */
      if(selectedIndicesRecordId.length > 0)
      {
        for each(var pastSelectedRecord:String in selectedIndicesRecordId)
        {
          for(var indice:String in recordsDataGrid.dataProvider)
          {
            if(pastSelectedRecord == recordsDataGrid.dataProvider[indice].id)
            {
              selectedIndices.push(indice);
              break;
            }
          }
        }
      }

      /** Select the rows that were selected before the refresh */
      if(selectedIndices.length > 0)
      {
        /** Select the record in the datagrid control */
        recordsDataGrid.selectedIndices = selectedIndices;

        /** Send the ListEvent.CHANGE event to notify all the controls that the records list selection changed */
        recordsDataGrid.dispatchEvent(new ListEvent("change"));
      }
      else
      {
        /** If no row were selected, select the first one */
        recordsDataGrid.selectedIndex = 0;

        /** Send the ListEvent.CHANGE event to notify all the controls that the records list selection changed */
        recordsDataGrid.dispatchEvent(new ListEvent("change"));
      }
    }

    /** Faulty browse structWSF event handler */
    private function filterResultsetFaultHandler(event:FaultEvent):void
    {
    /*      
        if(event.message.rootCause.target.data)
        {
          var errorMsg:XML = new XML(event.message.rootCause.target.data);
          
          if(errorMsg.description)
          {
            Alert.show(errorMsg.debugInformation, errorMsg.description);
            return;
          }
          else
          {
            Alert.show("Can't reach the remove structWSF instance");      
            return;
          }
        }
        else
        {
          Alert.show("Can't reach the remove structWSF instance");      
          return;
        }
    */
    }

    /** Get the titles of the datasets available to the workbench */
    private function getDatasetsTitles():void
    {
      /**
      * We get the name of all datasets define on this structWSF instance 
      * from the DatasetRead web service endpoint 
      */

      /**
      * Note: There is currently a bug in the Flash player that remove all headers we can
      *       set for a GET query. This means that only the default Accept header of the 
      *       browser are sent. This can cause issues depending on the browser (none with
      *       IE and FireFox.
      *        
      *       http://verveguy.blogspot.com/2008/07/truth-about-flex-httpservice.html
      *       https://bugs.adobe.com/jira/browse/FP-209
      */

      /** Web service querier */
      var httpService:HTTPService = new HTTPService();

      var requestParameters:Object = {uri: "all"};

      httpService.url = workbenchSettings.structWSFBaseURL + "/dataset/read/";
      httpService.method = "GET";
      httpService.headers['Accept'] = 'application/xml';
      httpService.showBusyCursor = true;
      httpService.resultFormat = "e4x";
      httpService.addEventListener(ResultEvent.RESULT, processDatasetsReadHandler);
      httpService.addEventListener(FaultEvent.FAULT, processDatasetsReadFaultHandler);

      httpService.send(requestParameters);
    }

    /** Handle errors returned by the DatasetRead web service endpoint */
    private function processDatasetsReadFaultHandler(event:FaultEvent):void
    {
    /*      
          if(event.message.rootCause.target.data)
          {
            var errorMsg:XML = new XML(event.message.rootCause.target.data);
            
            if(errorMsg.description)
            {
              Alert.show(errorMsg.debugInformation, errorMsg.description);
              return;
            }
            else
            {
              Alert.show("Can't read dataset descriptions");
              return;
            }
          }
          else
          {
            Alert.show("Can't read dataset descriptions");
            return;
          }
    */
    }

    /** Handle the resultset returned by the DatasetRead web service endpoint */
    private function processDatasetsReadHandler(event:ResultEvent):void
    {
      if(event.result is XML)
      {
        var resultset:Resultset = new Resultset(event.result);

        var datasets:Array = resultset.getSubjectsByType("void_Dataset");

        for each(var subject:Subject in datasets)
        {
          datasetsTitles[subject.uri] = subject.predicates["dcterms_title"][0].value;
        }
      }
      else
      {
        return;
      }

      var so:SharedObject = SharedObject.getLocal("sd_Workbench");

      so.data.datasets = datasetsTitles;

      so.flush();

      displayDatasets();
    }

    /** Display the datasets in the data filtering panel of the workbench */
    private function displayDatasets():void
    {
      var aggregates:Array = filteringResultset.getSubjectsByType("aggr_Aggregate");
      var datasetsAggregates:Array =
        filteringResultset.getSubjectsByPredicateObjectValue("aggr_property", "void_Dataset", aggregates);
      var datasets:Array = [];

      /** re-initialize the counts to be display to 0. In the following steps, counts will be re-populated */
      if(allDatasets.length > 0)
      {
        for each(var dataset:Object in allDatasets)
        {
          dataset.nbRecords = 0;
          dataset.displayLabel = dataset.prefLabel + " (" + dataset.nbRecords + ")";
          dataset.enabled = false;
        }
      }

      for each(var datasetAggregate:Subject in datasetsAggregates)
      {
        var datasetURI:String = datasetAggregate.predicates["aggr_object"][0].uri;
        var nbRecords:String = datasetAggregate.predicates["aggr_count"][0].value;

        if(!datasetsTitles[datasetURI])
        {
          /** 
          * If the dataset title is not existing, it means that the titles come from the local cache
          * and that a new dataset appeared on the structWSF instance.
          *   
          * This means that we have to re-fetch the dataset titles from the DatasetRead web service
          */

          getDatasetsTitles();

          return;
        }

        if(allDatasets.length > 0)
        {
          for each(var dataset:Object in allDatasets)
          {
            if(dataset.uri == datasetURI)
            {
              dataset.nbRecords = nbRecords;
              dataset.displayLabel = dataset.prefLabel + " (" + nbRecords + ")";
              dataset.enabled = (parseInt(nbRecords) == 0 ? false : true);
            }
          }
        }
        else
        {
          datasets.push({displayLabel: datasetsTitles[datasetURI] + " (" + nbRecords + ")",
            prefLabel: datasetsTitles[datasetURI], nbRecords: nbRecords, uri:datasetURI, 
            enabled: (parseInt(nbRecords) == 0 ? false : true)});
        }
      }

      datasets.sortOn("displayLabel", Array.ASCENDING);
      
      /**
      * If the allDatasets array is empty, we consider that this the result of the first call to the browse
      * web service, and so that it lists all datasets, kinds and attributes available to the user
      */
      if(allDatasets.length == 0)
      {
        allDatasets = datasets;
        datasetFilterList.dataProvider = allDatasets;
      }
      else
      {
        /** Update the data provider of the filtering lists */
        for(var i:String in datasetFilterList.dataProvider)
        {
          for each(var allDatasetsItem:Object in allDatasets)
          {
            if(datasetFilterList.dataProvider[i].uri == allDatasetsItem.uri)
            {
              datasetFilterList.dataProvider[i].nbRecords == allDatasetsItem.nbRecords;
              datasetFilterList.dataProvider[i].displayLabel == allDatasetsItem.displayLabel;
              break;
            }
          }
        }

        datasetFilterList.invalidateList();
      }

      displayKinds();
    }

    /** 
    * Display the types (kinds) of records available from all datasets handled by the workbench,                       
    * in the filtering panel 
    */
    private function displayKinds():void
    {
      /** 
      * Aggregates returned by the Browse web service endpoints. We calculate the number of records
      * for each type from these aggregates.
      */
      var aggregates:Array = filteringResultset.getSubjectsByType("aggr_Aggregate");

      var typesAggregates:Array =
        filteringResultset.getSubjectsByPredicateObjectValue("aggr_property", "rdf_type", aggregates);

      var types:Array = [];

      /** re-initialize the counts to be display to 0. In the following steps, counts will be re-populated */
      if(allKinds.length > 0)
      {
        for each(var t:Object in allKinds)
        {
          t.nbRecords = 0;
          t.displayLabel = t.prefLabel + " (" + t.nbRecords + ")";
          t.enabled = false;
        }
      }

      for each(var typeAggregate:Subject in typesAggregates)
      {
        var typeURI:String = typeAggregate.predicates["aggr_object"][0].uri;
        var nbRecords:String = typeAggregate.predicates["aggr_count"][0].value;

        var type:SchemaType = schema.getType(typeURI);
        var prefLabel:String = "";

        if(type == null)
        {
          /** no type defined in the schema for this type URI */
          var end:int = 0;
          var name:String = "";

          end = typeURI.lastIndexOf("#");

          if(end == -1)
          {
            end = typeURI.lastIndexOf("/");
          }

          if(end > 0)
          {
            end += 1;

            prefLabel = typeURI.substr(end, (typeURI.length - end));
          }
        }
        else
        {
          prefLabel = type.prefLabel;
        }

        if(allKinds.length > 0)
        {
          for each(var t:Object in allKinds)
          {
            if(t.uri == typeURI)
            {
              t.nbRecords = nbRecords;
              t.displayLabel = t.prefLabel + " (" + nbRecords + ")";
              t.enabled = (parseInt(nbRecords) == 0 ? false : true);
            }
          }
        }
        else
        {
          types.push({displayLabel: prefLabel + " (" + nbRecords + ")", prefLabel: prefLabel, nbRecords: nbRecords,
            uri:typeURI, enabled: (parseInt(nbRecords) == 0 ? false : true)});
        }
      }

      types.sortOn("displayLabel", Array.ASCENDING);
      
      /**
      * If the allDatasets array is empty, we consider that this the result of the first call to the browse
      * web service, and so that it lists all datasets, kinds and attributes available to the user
      */
      if(allKinds.length == 0)
      {
        allKinds = types;
        typeFilterList.dataProvider = allKinds;
      }
      else
      {
        /** Update the data provider of the filtering lists */
        for(var i:String in typeFilterList.dataProvider)
        {
          for each(var allKindsItem:Object in allKinds)
          {
            if(typeFilterList.dataProvider[i].uri == allKindsItem.uri)
            {
              typeFilterList.dataProvider[i].nbRecords == allKindsItem.nbRecords;
              typeFilterList.dataProvider[i].displayLabel == allKindsItem.displayLabel;
              break;
            }
          }
        }

        typeFilterList.invalidateList();
      }

      displayAttributes();
    }

    /** 
     * Display the attributes of records available from all datasets handled by the workbench,                       
     * in the filtering panel 
     */
    private function displayAttributes():void
    {
      var aggregates:Array = filteringResultset.getSubjectsByType("aggr_Aggregate");
      var attributesAggregates:Array =
        filteringResultset.getSubjectsByPredicateObjectValue("aggr_property", "rdf_Property", aggregates);
      var attributes:Array = [];

      /** re-initialize the counts to be display to 0. In the following steps, counts will be re-populated */
      if(allAttributes.length > 0)
      {
        for each(var attr:Object in allAttributes)
        {
          attr.nbRecords = 0;
          attr.displayLabel = attr.prefLabel + " (" + attr.nbRecords + ")";
          attr.enabled = false;
        }
      }

      for each(var attributeAggregate:Subject in attributesAggregates)
      {
        var attributeURI:String = attributeAggregate.predicates["aggr_object"][0].uri;
        var nbRecords:String = attributeAggregate.predicates["aggr_count"][0].value;

        var attribute:SchemaAttribute = schema.getAttribute(attributeURI);
        var prefLabel:String = "";

        if(attribute == null)
        {
          /** no type defined in the schema for this type URI */
          var end:int = 0;
          var name:String = "";

          end = attributeURI.lastIndexOf("#");

          if(end == -1)
          {
            end = attributeURI.lastIndexOf("/");
          }

          if(end > 0)
          {
            end += 1;

            prefLabel = attributeURI.substr(end, (attributeURI.length - end));
          }
        }
        else
        {
          prefLabel = attribute.prefLabel;
        }

        if(allAttributes.length > 0)
        {
          for each(var attr:Object in allAttributes)
          {
            if(attr.uri == attributeURI)
            {
              attr.nbRecords = nbRecords;
              attr.displayLabel = attr.prefLabel + " (" + nbRecords + ")";
              attr.enabled = (parseInt(nbRecords) == 0 ? false : true);
            }
          }
        }
        else
        {
          attributes.push({displayLabel: prefLabel + " (" + nbRecords + ")", prefLabel: prefLabel, nbRecords: nbRecords,
            uri:attributeURI, enabled: (parseInt(nbRecords) == 0 ? false : true)});
        }
      }

      attributes.sortOn("displayLabel", Array.ASCENDING);
      
      /**
      * If the allDatasets array is empty, we consider that this the result of the first call to the browse
      * web service, and so that it lists all datasets, kinds and attributes available to the user
      */
      if(allAttributes.length == 0)
      {
        allAttributes = attributes;

        attributeFilterList.dataProvider = allAttributes;
      }
      else
      {
        /** Update the data provider of the filtering lists */
        for(var i:String in attributeFilterList.dataProvider)
        {
          for each(var allAttributesItem:Object in allAttributes)
          {
            if(attributeFilterList.dataProvider[i].uri == allAttributesItem.uri)
            {
              attributeFilterList.dataProvider[i].nbRecords == allAttributesItem.nbRecords;
              attributeFilterList.dataProvider[i].displayLabel == allAttributesItem.displayLabel;
              break;
            }
          }
        }

        attributeFilterList.invalidateList();
      }
    }

    /** Get the list of records, for all the selected criterias, from a Browse web service endpoint */
    private function filterRecords():void
    {
      var datasets:String = "";
      var types:String = "";
      var attributes:String = "";
     
      if(filteredDatasets.length > 0)
      {
        for each(var dataset:String in filteredDatasets)
        {
          datasets = datasets + dataset + ";";
        }

        datasets = datasets.substr(0, datasets.length - 1);
      }
      else
      {
        if(workbenchSettings.filterDatasets.length > 0)
        {
          var i:int = 0;
          
          for each(var filter:String in workbenchSettings.filterDatasets)
          {
            if(i > 0)
            {
              datasets += (";" + filter);
            }
            else
            {
              datasets += filter;
            }
            
            i++;
          }
        }
        else
        {
          datasets = "all";
        }        
      }

      if(filteredKinds.length > 0)
      {
        for each(var type:String in filteredKinds)
        {
          types = types + type + ";";
        }

        types = types.substr(0, types.length - 1);
      }
      else
      {
        types = "all";
      }

      if(filteredAttributes.length > 0)
      {
        for each(var attribute:String in filteredAttributes)
        {
          attributes = attributes + attribute + ";";
        }

        attributes = attributes.substr(0, attributes.length - 1);
      }
      else
      {
        attributes = "all";
      }

      var requestParameters:Object = {
        datasets: datasets, 
        types: types, 
        attributes: attributes, 
        items: "300", 
        page: "0",
        include_inference: "true", 
        include_aggregates:"true", 
        include_attributes_list: includeAttributesList.join(";"),
        attributes_boolean_operator: "and"
      };

      var httpService:HTTPService = new HTTPService();

      httpService.url = workbenchSettings.structWSFBaseURL + "/search/";
      httpService.method = "POST";
      httpService.headers['Accept'] = 'text/xml;q=1';
      httpService.showBusyCursor = true;
      httpService.resultFormat = "e4x";
      httpService.addEventListener(ResultEvent.RESULT, filterResultsetHandler);
      httpService.addEventListener(FaultEvent.FAULT, filterResultsetFaultHandler);

      httpService.send(requestParameters);
    }

    /** A new record has been selected from the datagrid */
    private function newRecordsSelectedHandler(event:Event):void
    {
      if(selectionMode != "selection")
      {
        return;
      }

      var records:Array = [];

      /**
      * Records selection behaviors:
      *
      *   (1) When an indicator is clicked, a component is created to display information of all selected records.
      *   (2) When a record is clicked (selected), components are created for each attribute that describes
      *       the selected record, that are not indicator attributes. All non-numeric primitive allowed values
      *       that have a display-componet defined in the schema will be displayed that way.
      */

      /** Records Selection Behavior (1) */

      /** Get the description of the selected record(s) */
      for each(var recordIndice:int in event.target.selectedIndices)
      {
        /** record to be added to the list of records to feed to the visualization components */
        var record:Subject =
          filteringResultset.getSubjectByURI(recordsUriById[event.target.dataProvider[recordIndice].id]);

        /** 
        * If the record is not found in the filteringResultset array, we have to check in the selected
        * selectionsResultset one.
        */
        if(record == null)
        {
          record = selectionsResultset.getSubjectByURI(recordsUriById[event.target.dataProvider[recordIndice].id]);
        }

        /** 
        * Check if an indicator is selected, if so, we feed the record description to the 
        * dataProvider of the indicator 
        */
        if(record != null)
        {
          records.push(record);
        }
      }

      for each(var indicatorURI:String in selectedIndicators)
      {
        var indicatorControl:sControl = SemanticUtils.getChildById("indicator_" + indicatorURI, this.workbenchCanvas);

        if(indicatorControl)
        {
          indicatorControl.semanticDataProvider = new Resultset(records);
        }
      }

      /** Records Selection Behavior (2) */

      /** 
      * First, check if the component already exists. If it does, we will re-use it,
      * if it doesn't, we will create it.
      */

      /** 
      * If the record is not found in the filteringResultset array, we have to check in the selected
      * selectionsResultset one.
      */
      var lastSelectedRecord:Subject =
        filteringResultset.getSubjectByURI(recordsUriById[event.target.dataProvider[event.target.selectedIndex].id]);

      if(lastSelectedRecord == null)
      {
        lastSelectedRecord =
          selectionsResultset.getSubjectByURI(recordsUriById[event.target.dataProvider[event.target.selectedIndex].id]);
      }

      /**
      * List of all semantic components used to display attributes. This is to ensure that if two attributes
      * have the same related display component, then that we only create one panel, and not one for each of
      * them.
      */
      var usedComponents:Array = [];

      for(var recordAttribute:String in lastSelectedRecord.predicates)
      {
        var attr:SchemaAttribute = schema.getAttribute(recordAttribute);

        if(attr != null)
        {
          /** skip the sControl creation if it has already been created */
          var stopComponentCreation:Boolean = false;

          for each(var displayControl:String in attr.displayControls)
          {
            if(usedComponents.indexOf(displayControl) != -1)
            {
              stopComponentCreation = true;
              break;
            }
            else
            {
              usedComponents.push(displayControl);
            }
          }

          if(stopComponentCreation)
          {
            continue;
          }

          if((attr.allowedPrimitiveValues.indexOf("Uri") != -1 || 
              attr.allowedPrimitiveValues.indexOf("String") != -1) && 
             attr.displayControls.length > 0 &&
             attr.displayControls.indexOf("sBarChart") == -1 &&
             attr.displayControls.indexOf("sLinearChart") == -1             
             )
          {
            selectedNonIndicators.push(attr.uri);

            var panelId:String = "panel_" + attr.uri;
            var nonIndicatorControlId:String = "nonindicator_" + attr.uri;

            var targetNonIndicator:sControl = SemanticUtils.getChildById(nonIndicatorControlId, this.workbenchCanvas);

            /** Check if the component already exists. If it doesn't, we create it */
            if(targetNonIndicator == null)
            {
              /** Make sure that neither one of its sub or super attributes is already linked to a component */
              var subAttributes:Array = schema.getSubAttributes(attr.uri, true);

              if(subAttributes.length > 0)
              {
                for each(var sa:SchemaAttribute in subAttributes)
                {
                  targetNonIndicator = SemanticUtils.getChildById("nonindicator_" + sa.uri, this.workbenchCanvas);

                  if(targetNonIndicator != null)
                  {
                    break;
                  }
                }
              }

              if(targetNonIndicator == null)
              {
                var superAttributes:Array = schema.getSuperAttributes(attr.uri, true);

                if(superAttributes.length > 0)
                {
                  for each(var sa:SchemaAttribute in superAttributes)
                  {
                    targetNonIndicator = SemanticUtils.getChildById("nonindicator_" + sa.uri, this.workbenchCanvas);

                    if(targetNonIndicator != null)
                    {
                      break;
                    }
                  }
                }
              }
            }

            if(targetNonIndicator == null)
            {
              /** If no component have been created for that nonIndicator yet, we simply create it */

              /** Create a new panel for this indicator */

              var targetPanel:Pod = SemanticUtils.getChildById(panelId, this.document.workbenchCanvas);

              if(targetPanel == null)
              {
                var title:String = "";

                /** Create the Panel that will holds the non-indicator widget */

                if(records.length > 1)
                {
                  title = "Selected Records";
                }
                else
                {
                  title = lastSelectedRecord.getPrefLabel(generalSettings.prefLabelAttributes);
                }

                /** Create the indicator widget */

                var semanticControl:sControl = new sControl();

                /** Initialize the semantic control */
                semanticControl.id = nonIndicatorControlId;
                semanticControl.percentWidth = 100;
                semanticControl.percentHeight = 100;

                /** Enable drag-and-drop on the component */
                semanticControl.addEventListener(DragEvent.DRAG_ENTER, dragAcceptHandler);
                semanticControl.addEventListener(DragEvent.DRAG_DROP, dragDropHandler);

                /** 
                * Here, we want to add the super and sub attributes to the target 
                * attribute. Some semantic components are working differently
                * on attributes of the same "branch". Fr example sco_gisMap and
                * sco_relatedGisMap. Both attributes are used to display
                * layers of maps, and sco_relatedGisMap is a sub-attribute of
                * sco_gisMap
                */
                var targetAttributes:Array = [attr.uri];

                /** check for sub-attributes */
                var subAttributes:Array = schema.getSubAttributes(attr.uri, true);

                if(subAttributes.length > 0)
                {
                  for each(var sa:SchemaAttribute in subAttributes)
                  {
                    targetAttributes.push(sa.uri);
                  }
                }

                if(attr.superProperties.length > 0)
                {
                  for each(var ta:SchemaAttribute in schema.getSuperAttributes(attr.uri, true))
                  {
                    targetAttributes.push(ta.uri);
                  }

                  semanticControl.targetAttributes = targetAttributes;
                }
                else
                {
                  semanticControl.targetAttributes = new Array(attr.uri);
                }

                semanticControl.targetTypes = new Array(lastSelectedRecord.type);
                semanticControl.semanticDataProvider = null;
                semanticControl.schema = this.schema;

                this.addEventListener(FeatureEvent.FEATURE_SELECTED, mapFeatureSelectedHandler);

                /** Define a new contextual menu to use for this pod. We use it to rename the title of the pod */
                var menuItemRenameTitle:ContextMenuItem = new ContextMenuItem("Rename title...");
                
                menuItemRenameTitle.addEventListener(ContextMenuEvent.MENU_ITEM_SELECT, renamePodTitle);
                
                var customContextMenu:ContextMenu = new ContextMenu();
                
                /** Hide the default Flash menu items */
                customContextMenu.hideBuiltInItems();
                customContextMenu.customItems.push(menuItemRenameTitle);

                /** Add the new pod to the Dashboar */
                dashboard.addPod(panelId, title, semanticControl, false, customContextMenu);

                targetNonIndicator = semanticControl;
              }
            }

            /** Populate the components with the values */
            if(targetNonIndicator != null)
            {
              targetNonIndicator.semanticDataProvider = new Resultset(records);
            }
          }
        }
      }

    /** Update the comparison component as well */
    //      updateStickyComparisonChart();
    }

    /**
     * Tells the user interface that the sControl component accept drag and drop events.
     * 
     * @param event DragEvent sent by Flex
     * 
     * @return Returns nothing
     */
    public function dragAcceptHandler(event:DragEvent):void
    {
      if(selectionMode != "drag")
      {
        return;
      }

      var dropTarget:sControl = event.currentTarget as sControl;
      DragManager.acceptDragDrop(dropTarget);
    }

    /**
     * Handle a drop event on the sControl component. From there, we check what
     * row of the records selector DataGrid component were selected, and we
     * add these records to the target component.
     * 
     * @param event DragEvent sent by Flex
     * 
     * @return Returns nothing
     */
    public function dragDropHandler(event:DragEvent):void
    {
      if(selectionMode != "drag")
      {
        return;
      }

      if(event.dragInitiator is DataGrid)
      {
        var recordsSelector:DataGrid = event.dragInitiator as DataGrid;

        for each(var recordIndice:int in recordsSelector.selectedIndices)
        {
          /** create the set of records to feed to the sControl */

          /** record to be added to the list of records to feed to the visualization components */
          var record:Subject =
            filteringResultset.getSubjectByURI(recordsUriById[recordsSelector.dataProvider[recordIndice].id]);

          /** 
           * If the record is not found in the filteringResultset array, we have to check in the selected
           * selectionsResultset one.
           */
          if(record == null)
          {
            record = selectionsResultset.getSubjectByURI(recordsUriById[recordsSelector.dataProvider[recordIndice].id]);
          }

          /** 
           * Check if an indicator is selected, if so, we feed the record description to the 
           * dataProvider of the indicator 
           */
          if(record != null)
          {
            var rset:Resultset = event.currentTarget.semanticDataProvider as Resultset;

            rset.addSubject(record);

            event.currentTarget.semanticDataProvider = rset;
          }
        }
      }
    }

    /**
    * Each time a feature is selected in the map, a FeatureEvent.SELECTED event is thrown. This function
    * tries to find a record in the recordlist (datagrid control), and to select it. Once it get selected
    * in the datagrid list, all other related controls get updated with the new select. So, each time
    * a map feature is selected, it impacts the behaviors of the other, opened, components.
    * 
    * @param event FeatureEvent sent by the map component
    * 
    * @see org.sunlightlabs.ClearMaps.FeatureEvent
    * 
    * @return Returns nothing
    */
    private function mapFeatureSelectedHandler(event:FeatureEvent):void
    {
      /** 
       * Each time a feature in a map is clicked, we try to select it in the DataGrid component of the Workbench.
       * If the selected feature is not linked to a record that belongs to the datagrid, we try to get it from
       * the related structWSF node. If we can find it, then we add it to the datagrid, otherwise we ignore the
       * click on the Map.     
       */

      targetRecordUri = event.feature.recordBaseUri + String(event.feature.data.exturi).replace(/(\t|\n|\s{2,})/g, '');

      for(var gridIndex:String in recordsDataGrid.dataProvider)
      {
        /** Check if the selected feature's record is in the datagrid list. */
        if(recordsUriById[Number(gridIndex) + 1] == targetRecordUri)
        {
          var selectedIndices:Array = recordsDataGrid.selectedIndices;

          /** We preserve the list of selected items and add the new one */
          recordsDataGrid.selectedIndex = gridIndex;

          selectedIndices.push(gridIndex);

          /** We select the record(s) in the datagrid control */
          recordsDataGrid.selectedIndices = selectedIndices;

          /** We send the ListEvent.CHANGE event to notify all the controls that the records list selection changed */
          recordsDataGrid.dispatchEvent(new ListEvent("change"));

          return;
        }
      }

      /**
      * If the record is not included in the current records list, we try to get its description
      * from the structWSF instance by using the CrudRead web service endpoint.
      */
      var httpService:HTTPService = new HTTPService();

      var requestParameters:Object = {uri: targetRecordUri};

      httpService.url = workbenchSettings.structWSFBaseURL + "/crud/read/";
      httpService.method = "GET";
      httpService.headers['Accept'] = 'application/xml';
      httpService.showBusyCursor = true;
      httpService.resultFormat = "e4x";
      httpService.addEventListener(ResultEvent.RESULT, processCrudReadSelectionHandler);

      httpService.send(requestParameters);
    }

    /**
    * Get the record description of a set of sticky records (one or multiple). These sticky records are
    * used for comparison purposes in the Workbench. Whatever the action performed by the user, these
    * records will remain in the workbench.
    * 
    * @param records URI(s) of the records we have to get description of. 
    */
    private function getStickyRecordsDescription(records:Array):void
    {
      /** 
      * "uri" parameter sent to the CrudRead web service endpoint. This is the list of record URI(s) for which
      * we need their record description.
      */
      var recordsToQuery:String = "";

      for each(var record:String in records)
      {
        /** Used to know if we should include the subject in the CrudRead query */
        var doNotInclude = false;

        /** check if the target record is already in the stickyResultset */
        if(stickyResultset && stickyResultset.hasOwnProperty("subjects"))
        {
          for each(var subject:Subject in stickyResultset.subjects)
          {
            if(subject.uri == record)
            {
              doNotInclude = true;
              break;
              p
            }
          }
        }

        if(doNotInclude == false)
        {
          recordsToQuery = recordsToQuery + record + ";";
        }
      }

      /** remove trailing ";" character */
      recordsToQuery = recordsToQuery.substring(0, recordsToQuery.length - 1);

      /**
       * Get the description of the sticky records from the CrudRead web service endpoint.
       */
      var httpService:HTTPService = new HTTPService();

      var requestParameters:Object = {uri: recordsToQuery};

      httpService.url = workbenchSettings.structWSFBaseURL + "/crud/read/";
      httpService.method = "GET";
      httpService.headers['Accept'] = 'application/xml';
      httpService.showBusyCursor = true;
      httpService.resultFormat = "e4x";
      httpService.addEventListener(ResultEvent.RESULT, processCrudReadStickyHandler);

      httpService.send(requestParameters);
    }

    /**
    * Parse a CrudRead resultset and add the record to the records list accessible in the DataGrid.
    * 
    * @param event ResultEvent sent by the HTTPService
    * 
    * @see mx.rpc.http.HTTPService
    * @see mx.rpc.events.ResultEvent
    * 
    * @return Returns nothing
    * 
    */
    private function processCrudReadSelectionHandler(event:ResultEvent):void
    {
      if(event.result is XML)
      {
        /** Parse the resultset */

        /** resultset of the CrudRead query */
        var resultset:Resultset = new Resultset(event.result);

        /** list of subjects to select in the datagrid */
        var recordsToSelect:Array = [];

        if(selectionsResultset == null)
        {
          /** If the selectionsResultset is null, we create it from the CrudRead resultset */

          selectionsResultset = resultset;

          for each(var subject:Subject in resultset.subjects)
          {
            recordsToSelect.push(subject);
          }
        }
        else
        {
          for each(var subject:Subject in resultset.subjects)
          {
            /**
            * For each parsed subject of the CrudRead resultset, we add them to the selectionsResultset resultset
            * This resultset is populated from clicks from different component of the Workbench. These are added
            * to the filteringResultset resultset in the DataGrid selection control.
            */
            selectionsResultset.addSubject(subject);

            recordsToSelect.push(subject);
          }
        }

        /** Once the subject(s) are added, we refresh the datagrid */
        refreshRecordsSelector(recordsToSelect);
      }
      else
      {
        return;
      }
    }

    /**
     * Parse a CrudRead resultset and add the record(s) to the "stickyResultset". These are records descriptions
     * that are used to populate sticky records that are kept in the Workbench whatever the action the user
     * perform.
     * 
     * @param event ResultEvent sent by the HTTPService
     * 
     * @see mx.rpc.http.HTTPService
     * @see mx.rpc.events.ResultEvent
     * 
     * @return Returns nothing
     * 
     */
    private function processCrudReadStickyHandler(event:ResultEvent):void
    {
      if(event.result is XML)
      {
        /** Parse the resultset */

        /** resultset of the CrudRead query */
        var resultset:Resultset = new Resultset(event.result);

        if(stickyResultset == null)
        {
          /** If the stickyResultset is null, we create it from the CrudRead resultset */
          stickyResultset = resultset;
        }
        else
        {
          for each(var subject:Subject in resultset.subjects)
          {
            /**
             * For each parsed subject of the CrudRead resultset, we add them to the stickyResultset resultset
             */
            stickyResultset.addSubject(subject);
          }
        }
      }
      else
      {
        return;
      }
    }

    /** Toggle on/off the fullscreen mode of the workbench */
    private function toggleFullScreen():void
    {
      try
      {
        switch(systemManager.stage.displayState)
        {
          case StageDisplayState.FULL_SCREEN:
          {
            /** If already in full screen mode, switch to normal mode. */
            systemManager.stage.displayState = StageDisplayState.NORMAL;
          }
          break;
          default:

          {
            /** If not in full screen mode, switch to full screen mode. */
            systemManager.stage.displayState = StageDisplayState.FULL_SCREEN;
          }
          break;
        }
      }
      catch(err:SecurityError)
      {
      /** ignore */
      }
    }

    /** Handle menu-bar menu selection */
    private function menuBarHandler(event:MenuEvent):void
    {
      switch(event.label)
      {
        case "Normal Screen":
        {
          if(systemManager.stage.displayState == StageDisplayState.FULL_SCREEN)
          {
            toggleFullScreen();
            return;
          }
        }
        break;
        case "Full Screen":
        {
          if(systemManager.stage.displayState != StageDisplayState.FULL_SCREEN)
          {
            Alert.show("When in full screen mode, due to Flash Player, users cannot enter text in text input fields." +
              " All keyboard inputs and key-related actions are disabled with the exception of" +
              " ESC to leave the full screen mode. This means that users won't be able to" +
              " select multiple records in the records selection while in full screen mode", "Notice");
            toggleFullScreen();
            return;
          }
        }
        case "List Selection":
        selectionMode = "selection";
        recordsSelectorPanel.title = "Records selector (list selection mode)";
        return;
        break;
        case "Drag-and-Drop":
        selectionMode = "drag";
        recordsSelectorPanel.title = "Records selector (drag-and-drop mode)";
        return;
        break;

        case "Create tab":
        var createTab:CreateTabTileWindow =
          CreateTabTileWindow(PopUpManager.createPopUp(this, CreateTabTileWindow, true));
        return;
        break;
      }

      /** Check if the event come from the "view" menu item */
      var indice:int = 0;

      for each(var control:Object in viewControls)
      {
        if(control.label == event.label)
        {
          /** show the panel */
          var panel:SuperPanelPlus = SemanticUtils.getChildById(control.id, this);

          panel.visible = true;
          panel.alpha = 1;
          panel.includeInLayout = true;

          /** remove the panel from the viewControls list */
          viewControls.splice(indice, 1);

          refreshViewMenu();

          return;
        }

        indice++;
      }

      switch(event.item.@action.toString())
      {
        case "rename_tab":
        var renameTab:RenameTabTileWindow =
          RenameTabTileWindow(PopUpManager.createPopUp(this, RenameTabTileWindow, true));

        renameTab.existingTabName = event.label;

        return;
        break;
        case "delete_tab":

        dashboard.removeTab(event.label);

        return;
        break;
        case "save_dashboard":

        var saveSession:SaveSessionTileWindow =
          SaveSessionTileWindow(PopUpManager.createPopUp(this, SaveSessionTileWindow, true));

        return;
        break;
        case "load_dashboard":

        var loadSession:LoadSessionTileWindow =
          LoadSessionTileWindow(PopUpManager.createPopUp(this, LoadSessionTileWindow, true));

        return;
        break;

        case "get_html":
        var htmlCode:HtmlCodeTileWindow = HtmlCodeTileWindow(PopUpManager.createPopUp(this, HtmlCodeTileWindow, true));

        return;
        break;
        
        case "select_indocators":
          /** 
           * Display the tile window that asks to select a series of indicators to use 
           * for the Workbench
           */ 
          var selectIndicatorsTileWindow:SelectIndicatorsTileWindow =
          SelectIndicatorsTileWindow(PopUpManager.createPopUp(this, SelectIndicatorsTileWindow, true));
        return;
        break;
      }
    }

    /** 
    * Load a dashboard session from the server
    * @param file URL of the file defining the dashboard session to load
    */
    public function loadDashboardSession(file:String):void
    {
      var httpService:HTTPService = new HTTPService();

      var requestParameters:Object = {};

      loadedSessionFile = file;

      httpService.url = file;
      httpService.method = "GET";
      httpService.headers['Accept'] = 'text/xml';
      httpService.showBusyCursor = true;
      httpService.resultFormat = "e4x";
      httpService.addEventListener(ResultEvent.RESULT, sessionsLoadResultsetHandler);
      httpService.addEventListener(FaultEvent.FAULT, sessionsLoadResultsetFaultHandler);

      httpService.send(requestParameters);
    }

    /** Faulty Sessions List event handler */
    private function sessionsLoadResultsetFaultHandler(event:FaultEvent):void
    {
      Alert.show("Sessions cannot be read from the server. Connection error.", "Connection Error");
    }

    /** Sessions list event handler */
    private function sessionsLoadResultsetHandler(event:ResultEvent):void
    {
      /** First, propagate the schema of the workbench to the one of the Dashboard. */
      if(dashboard.schema)
      {
        for each(var s:XML in this.schema.schema)
        {
          dashboard.schema.appendSchema(s);
        }
      }
      else
      {
        registerClassAlias("com.sd.semantic.core.Schema", Schema);
        registerClassAlias("com.sd.semantic.core.Namespaces", Namespaces);

        dashboard.schema = ObjectUtil.copy(this.schema) as Schema;
      }

      /** Load the session in the Dashboard */
      dashboard.loadSession(event.result);

      /** Change the mode to "drag-and-drop" */
      selectionMode = "drag";
      recordsSelectorPanel.title = "Records selector (drag-and-drop mode)";

      /** Remove all the references to all previously selected indicators */
      selectedIndicators = [];      
      
      /** Make sure that all the sControl accept the dragged-and-dropped elements */
      /*
      var controls:Array = [];

      SemanticUtils.getChildrenRecur([this], controls);

      for each(var control:Object in controls)
      {
        if(control is sControl)
        {
          control.addEventListener(DragEvent.DRAG_ENTER, dragAcceptHandler);
          control.addEventListener(DragEvent.DRAG_DROP, dragDropHandler);
        }
      }
      */
      
      /**
      * Try to load the columns that are in the dashboard session but that may be missing in the workbench
      */
      
      var namespaces:Namespaces = new Namespaces();
      
      for each(var tab:XML in event.result.tabs.tab)
      {
        for each(var pod:XML in tab.pods.pod)
        {
          for each(var targetAttribute:XML in pod.control.targetAttributes.targetAttribute)
          {
            if(includeAttributesList.indexOf(targetAttribute.toString()) == -1)
            {
              includeAttributesList.push(namespaces.getNamespace(targetAttribute.toString()));
              selectedIndicators.push(targetAttribute.toString());
            }
          }
        }
      }      
      
      /** Initialize the workbench with the proper data and columns */
      getInitialRecords();
      

      /** 
      * Make sure that for all loaded controls, we check the column (if it exists) in the
      * records selector panel.
      */

      /** 
      * Re-populate the selected indicators list with the possible values
      * (possible values are the ones that for which a column exist for the records being loaded)
      */

      for each(var tab:XML in event.result.tabs.tab)
      {
        for each(var pod:XML in tab.pods.pod)
        {
          for each(var targetAttribute:XML in pod.control.targetAttributes.targetAttribute)
          {
            /** Make sure that a column exists for this target attribute */
            for each(var column:Object in recordsDataGrid.columns)
            {
              if(column is DataGridIndicatorColumn)
              {
                if(column.indicatorAttribute.uri && column.indicatorAttribute.uri == targetAttribute.toString()
                  && selectedIndicators.indexOf(column.indicatorAttribute.uri) == -1)
                {
                  selectedIndicators.push(column.indicatorAttribute.uri);
                  break;
                }
              }
            }
          }
        }
      }

      /** Selected records in that session */
      var selectedSessionRecords:Array = [];

      for each(var tab:XML in event.result.tabs.tab)
      {
        for each(var subject:XML in tab.pods.pod.control.resultset.subject)
        {
          selectedSessionRecords.push(new Subject(subject, []));
        }
      }

      refreshRecordsSelector(selectedSessionRecords);
    }

    /**
    * Save the current wordkbench dashboard into a dashboard session file on the server.
    * @param title Title of the dashboard session
    * @param password Password to send to the server to save the session. This password will be "encrypted"
    *                 using MD5 before being sent to the server so that it is not transmitted into plain text.
    */
    public function saveDashboardSession(title:String = "", password:String = ""):void
    {
      var sessionXML:String = "<?xml version=\"1.0\"?>\n";

      sessionXML += "<dashboardSession>\n";

      sessionXML += "  <title>" + title + "</title>\n";

      sessionXML += "  <schemas>\n";

      for each(var s:XML in schema.schema)
      {
        sessionXML += s.toString();
      }

      sessionXML += "  </schemas>\n";

      sessionXML += "  <tabs>\n";

      var tabIterator:int = 0;

      for each(var manager:PodLayoutManager in dashboard.podLayoutManagers)
      {
        sessionXML += "    <tab>\n";
        sessionXML += "      <title>" + manager.container.label + "</title>\n";

        if(tabIterator == dashboard.tabBar.selectedIndex)
        {
          sessionXML += "      <selected>true</selected>\n";
        }
        else
        {
          sessionXML += "      <selected>false</selected>\n";
        }

        sessionXML += "      <pods>\n";

        /** Add non maximized pods */
        for each(var pod:Pod in manager.items)
        {
          sessionXML += "        <pod id=\"" + pod.id + "\">\n";
          sessionXML += "          <title>" + pod.title + "</title>\n";
          sessionXML += "          <minimized>false</minimized>\n";
          
          if(pod.getChildAt(0).displayControlSwitcher)
          {
            sessionXML += "          <showControlSwitcher>true</showControlSwitcher>\n";
          }
          else
          {
            sessionXML += "          <showControlSwitcher>false</showControlSwitcher>\n";
          }

          sessionXML += "          <control id=\"" + pod.getChildAt(0).id + "\">\n";

          sessionXML += "            <targetAttributes>\n";

          for each(var targetAttribute:String in pod.getChildAt(0).targetAttributes)
          {
            sessionXML += "              <targetAttribute>" + targetAttribute + "</targetAttribute>\n";
          }

          sessionXML += "            </targetAttributes>\n";

          sessionXML += "            <targetTypes>\n";

          for each(var targetType:String in pod.getChildAt(0).targetTypes)
          {
            sessionXML += "              <targetType>" + targetType + "</targetType>\n";
          }

          sessionXML += "            </targetTypes>\n";

          var selectedComponentObj:Object = pod.getChildAt(0).getChildAt(0).getChildAt(0);
          var selectedComponentObjName:String = flash.utils.getQualifiedClassName(selectedComponentObj);
          
          if(selectedComponentObjName == "sBarChart" ||
            selectedComponentObjName == "sLinearChart")
          {
            sessionXML += "            <vScale min=\""+selectedComponentObj.vScale.minValue+"\" max=\""+selectedComponentObj.vScale.maxValue+"\" />\n";
          }
          
          if(selectedComponentObjName == "sBarChart" ||
             selectedComponentObjName == "sLinearChart")
          {
            sessionXML += "            <vAxisLabel>"+selectedComponentObj.getVerticalAxisLabel()+"</vAxisLabel>\n";
          }
          
          sessionXML += "            <selectedComponent>"
            + selectedComponentObjName +
            "</selectedComponent>\n";

          sessionXML += "              <resultset>\n";
          sessionXML += "                <prefix entity=\"owl\" uri=\"http://www.w3.org/2002/07/owl#\"/>\n";
          sessionXML
            += "                <prefix entity=\"rdf\" uri=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"/>\n";
          sessionXML += "                <prefix entity=\"rdfs\" uri=\"http://www.w3.org/2000/01/rdf-schema#\"/>\n";

          for each(var subject:Subject in pod.getChildAt(0).semanticDataProvider.subjects)
          {
            sessionXML += subject.getXMLSerialization(false);
          }

          sessionXML += "              </resultset>\n";

          sessionXML += "          </control>\n";

          sessionXML += "        </pod>\n";
        }

        /** Add minimized pods */
        for each(var pod:Pod in manager.minimizedItems)
        {
          sessionXML += "        <pod id=\"" + pod.id + "\">\n";
          sessionXML += "          <title>" + pod.title + "</title>\n";
          sessionXML += "          <minimized>true</minimized>\n";
                    
          if(pod.getChildAt(0).displayControlSwitcher)
          {
            sessionXML += "          <showControlSwitcher>true</showControlSwitcher>\n";
          }
          else
          {
            sessionXML += "          <showControlSwitcher>false</showControlSwitcher>\n";
          }         

          sessionXML += "          <control id=\"" + pod.getChildAt(0).id + "\">\n";

          sessionXML += "            <targetAttributes>\n";

          for each(var targetAttribute:String in pod.getChildAt(0).targetAttributes)
          {
            sessionXML += "              <targetAttribute>" + targetAttribute + "</targetAttribute>\n";
          }

          sessionXML += "            </targetAttributes>\n";

          sessionXML += "            <targetTypes>\n";

          for each(var targetType:String in pod.getChildAt(0).targetTypes)
          {
            sessionXML += "              <targetType>" + targetType + "</targetType>\n";
          }

          sessionXML += "            </targetTypes>\n";

          sessionXML += "            <selectedComponent>"
            + flash.utils.getQualifiedClassName(pod.getChildAt(0).getChildAt(0)) +
            "</selectedComponent>\n";

          sessionXML += "              <resultset>\n";
          sessionXML += "                <prefix entity=\"owl\" uri=\"http://www.w3.org/2002/07/owl#\"/>\n";
          sessionXML
            += "                <prefix entity=\"rdf\" uri=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"/>\n";
          sessionXML += "                <prefix entity=\"rdfs\" uri=\"http://www.w3.org/2000/01/rdf-schema#\"/>\n";

          for each(var subject:Subject in pod.getChildAt(0).semanticDataProvider.subjects)
          {
            sessionXML += subject.getXMLSerialization(false);
          }

          sessionXML += "              </resultset>\n";

          sessionXML += "          </control>\n";

          sessionXML += "        </pod>\n";
        }

        sessionXML += "      </pods>\n";

        sessionXML += "    </tab>\n";

        tabIterator++;
      }

      sessionXML += "  </tabs>\n";

      sessionXML += "</dashboardSession>\n";

      var md5:MD5 = new MD5();

      var requestParameters:Object = {password: md5.encrypt(password), session: sessionXML, title:title};

      var httpService:HTTPService = new HTTPService();

      httpService.url = workbenchSettings.dashboardSessionsServerBaseUrl + "sessionSave.php";
      httpService.method = "POST";
      httpService.headers['Accept'] = 'text/xml;q=1';
      httpService.showBusyCursor = true;
      httpService.resultFormat = "e4x";
      httpService.addEventListener(ResultEvent.RESULT, sessionSaveResultsetHandler);
      httpService.addEventListener(FaultEvent.FAULT, sessionSaveResultsetFaultHandler);

      httpService.send(requestParameters);
    }

    /** Faulty session save event handler */
    private function sessionSaveResultsetFaultHandler(event:FaultEvent):void
    {
      Alert.show("Session cannot be saved on the server. Connection error.", "Connection Error");
    }

    /** Session Save event handler */
    private function sessionSaveResultsetHandler(event:ResultEvent):void
    {
      var answer:XML = new XML(event.result);

      if(answer.status.toString() == "error")
      {
        Alert.show(answer.msg.toString(), "Error");
      }
      else
      {
        Alert.show("Saved", "Successfully saved");
      }

      loadedSessionFile = answer.msg.toString();
    }

    /** Hide a panel (this happen when the user clicks on the "x" top right button of a window */
    private function hidePanelHandler(event:Event):void
    {
      /** Remove the reference to this selected indicator */
      selectedNonIndicators.splice(selectedNonIndicators.indexOf(event.target.id.replace("panel_", "nonindicator_")),
        1);

      event.target.alpha = 0;
      event.target.visible = false;
      event.target.includeInLayout = false;

      viewControls.push({label: event.target.title, id:event.target.id});

      refreshViewMenu();
    }

    /** Refresh the items to display in the "view" menu of the top menu-bar */
    private function refreshViewMenu():void
    {
      /** String used to create the XML source to populate the View menu */
      var viewMenuXML:String = "<menuitem label=\"View\">";

      if(viewControls.length == 0)
      {
        viewMenuXML += "<menuitem label=\"No panels to show...\" enabled=\"false\"/>";
      }
      else
      {
        for each(var control:Object in viewControls)
        {
          viewMenuXML += "<menuitem label=\"" + control.label + "\"/>";
        }
      }

      viewMenuXML += "</menuitem>";

      menuBar.menus[1].dataProvider = XML(viewMenuXML);
    }

    /** Refresh the items to display in the "rename tab" menu of the top menu-bar */
    public function refreshRenameTabMenu():void
    {
      /** String used to create the XML source to populate the View menu */
      var renameTabMenuXML:String = "";

      renameTabMenuXML += "<menuitem label=\"Rename tab\">";

      for each(var manager:PodLayoutManager in dashboard.podLayoutManagers)
      {
        renameTabMenuXML += "<menuitem label=\"" + manager.container.label + "\" action=\"rename_tab\"/>";
      }

      renameTabMenuXML += "</menuitem>";

      if(menuBar.menus[3] && menuBar.menus[3].dataProvider[3])
      {
        menuBar.menus[3].dataProvider[3] = XML(renameTabMenuXML);
      }
    }

    /** Refresh the items to display in the "delete tab" menu of the top menu-bar */
    public function refreshDeleteTabMenu():void
    {
      /** String used to create the XML source to populate the View menu */
      var deleteTabMenuXML:String = "";

      deleteTabMenuXML += "<menuitem label=\"Delete tab\">";

      for each(var manager:PodLayoutManager in dashboard.podLayoutManagers)
      {
        deleteTabMenuXML += "<menuitem label=\"" + manager.container.label + "\" action=\"delete_tab\"/>";
      }

      deleteTabMenuXML += "</menuitem>";

      if(menuBar.menus[3] && menuBar.menus[3].dataProvider[4])
      {
        menuBar.menus[3].dataProvider[4] = XML(deleteTabMenuXML);
      }
    }     
    
    public function renamePodTitle(event:ContextMenuEvent):void
    {
      var renamePod:RenamePodTileWindow =
        RenamePodTileWindow(PopUpManager.createPopUp(this, RenamePodTileWindow, true));
      
      renamePod.targetPod = event.contextMenuOwner;      
    }  

    ]]>
  </mx:Script>

  <mx:MenuBar id="menuBar" top="-1" right="0" left="0" height="32" labelField="@label"
    itemClick="menuBarHandler(event)">
    <mx:XMLList>
      <menuitem label="Window">
        <menuitem label="Normal Screen" groupName="window" type="radio" toggled="true"/>

        <menuitem label="Full Screen" groupName="window" type="radio"/>
      </menuitem>

      <menuitem label="View">
        <menuitem label="No panels to show..." enabled="false"/>
      </menuitem>

      <menuitem label="Records Selection Mode">
        <menuitem label="List Selection" groupName="recordselmode" type="radio" toggled="true"/>

        <menuitem label="Drag-and-Drop" groupName="recordselmode" type="radio"/>
      </menuitem>

      <menuitem label="Dashboard">
        <menuitem label="Save..." action="save_dashboard"/>

        <menuitem label="Load..." action="load_dashboard"/>

        <menuitem label="Create tab" action="create_tab"/>

        <menuitem label="Rename tab">
          <menuitem label="Main" action="rename_tab"/>
        </menuitem>

        <menuitem label="Delete tab">
          <menuitem label="Main" action="delete_tab"/>
        </menuitem>

        <menuitem label="Get HTML Code to Embed" action="get_html"/>
      </menuitem>
      <menuitem label="Records">
        <menuitem label="Select Indicators..." action="select_indocators" />
      </menuitem>
    </mx:XMLList>
  </mx:MenuBar>

  <mx:Canvas id="workbenchCanvas" top="32" width="100%" height="100%" verticalScrollPolicy="off"
    horizontalScrollPolicy="off">
    <panel:SuperPanelPlus id="filteringPanel" styleName="filteringPanelStyle" x="0" y="0" width="200" height="99%"
      layout="absolute" title="Filter information" showControls="true" dragEnabled="true" resizeEnabled="true"
      closeClickEvent="hidePanelHandler(event)">
      <mx:VDividedBox x="0" y="0" width="100%" height="100%" liveDragging="true">
        <mx:VBox width="100%" height="33%">
          <mx:Label text="Dataset" width="100%" textAlign="center" fontWeight="bold"/>

          <mx:Canvas width="100%" height="100%">
            <toolbox:CheckBoxList id="datasetFilterList" width="100%" height="100%"
              labelField="displayLabel" enabledField="enabled" change="onDatasetFilterListChangeHandler(event);">
              <mx:Script>
                <![CDATA[

                private function onDatasetFilterListChangeHandler(event:Event):void
                {
                  if(this.filteredDatasets.indexOf(event.itemRenderer.data.uri) == -1)
                  {
                    this.filteredDatasets.push(event.itemRenderer.data.uri);
                  }
                  else
                  {
                    this.filteredDatasets.splice(this.filteredDatasets.indexOf(event.itemRenderer.data.uri), 1);
                  }

                  filterRecords();
                }

                ]]>
              </mx:Script>
            </toolbox:CheckBoxList>
          </mx:Canvas>
        </mx:VBox>

        <mx:VBox width="100%" height="34%">
          <mx:Label text="Kinds" width="100%" textAlign="center" fontWeight="bold"/>

          <mx:Canvas width="100%" height="100%">
            <toolbox:CheckBoxList id="typeFilterList" width="100%" height="100%"
              labelField="displayLabel" enabledField="enabled" change="onTypeFilterListChangeHandler(event);">
              <mx:Script>
                <![CDATA[

                private function onTypeFilterListChangeHandler(event:Event):void
                {
                  if(this.filteredKinds.indexOf(event.itemRenderer.data.uri) == -1)
                  {
                    this.filteredKinds.push(event.itemRenderer.data.uri);
                  }
                  else
                  {
                    this.filteredKinds.splice(this.filteredKinds.indexOf(event.itemRenderer.data.uri), 1);
                  }

                  filterRecords();
                }

                ]]>
              </mx:Script>
            </toolbox:CheckBoxList>
          </mx:Canvas>
        </mx:VBox>

        <mx:VBox width="100%" height="33%">
          <mx:Label text="Attributes" width="100%" textAlign="center" fontWeight="bold"/>

          <mx:Canvas width="100%" height="100%">
            <toolbox:CheckBoxList id="attributeFilterList" width="100%" height="100%"
              labelField="displayLabel" enabledField="enabled" change="onAttributeFilterListChangeHandler(event);">
              <mx:Script>
                <![CDATA[

                private function onAttributeFilterListChangeHandler(event:Event):void
                {
                  if(this.filteredAttributes.indexOf(event.itemRenderer.data.uri) == -1)
                  {
                    this.filteredAttributes.push(event.itemRenderer.data.uri);
                  }
                  else
                  {
                    this.filteredAttributes.splice(this.filteredAttributes.indexOf(event.itemRenderer.data.uri), 1);
                  }

                  filterRecords();
                }

                ]]>
              </mx:Script>
            </toolbox:CheckBoxList>
          </mx:Canvas>
        </mx:VBox>
      </mx:VDividedBox>
    </panel:SuperPanelPlus>

    <panel:SuperPanelPlus id="recordsSelectorPanel" x="200" y="0" width="100%" height="300" layout="absolute"
      title="Records selector (list selection mode)" showControls="true" dragEnabled="true" resizeEnabled="true"
      closeClickEvent="hidePanelHandler(event)" verticalScrollPolicy="off" horizontalScrollPolicy="off">
      <mx:DataGrid id="recordsDataGrid" width="100%" height="100%" allowMultipleSelection="true"
        horizontalScrollPolicy="auto" verticalScrollPolicy="auto" change="newRecordsSelectedHandler(event)"
        dragEnabled="true">
      </mx:DataGrid>
    </panel:SuperPanelPlus>

    <panel:SuperPanelPlus id="dashboardPanel" x="201" y="301" width="100%" height="100%" layout="absolute"
      title="Dashboard" showControls="true" dragEnabled="true" resizeEnabled="true"
      closeClickEvent="hidePanelHandler(event)" verticalScrollPolicy="off" horizontalScrollPolicy="off">
      <!--components:sDashboard id="dashboard" width="100%" height="100%" creationComplete="setup()">
        <mx:Script>
          <![CDATA[

          private function setup():void
          {
            /** Properly position the minimize, maximaze and resize buttons on the SuperPanel */
            dashboardPanel.positionChildren();

            /** Create the initial tab */
            dashboard.addTab("Main");
          }

          ]]>
        </mx:Script>
      </components:sDashboard-->
    </panel:SuperPanelPlus>
  </mx:Canvas>
</mx:Application>