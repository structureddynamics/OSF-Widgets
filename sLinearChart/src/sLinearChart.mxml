<?xml version="1.0" encoding="utf-8"?>

<mx:Module width="100%" height="100%" backgroundAlpha="0"
           xmlns:toolbox = "com.flextoolbox.controls.*" xmlns:mx="http://www.adobe.com/2006/mxml" xmlns:axiis="org.axiis.*"
           xmlns:axis="org.axiis.charts.axis.*" xmlns:degrafa="http://www.degrafa.com/2007"
           xmlns:charts="org.axiis.charts.*" xmlns:geometry="com.degrafa.geometry.*" xmlns:layouts="org.axiis.layouts.*"
           xmlns:series="org.axiis.charts.series.*" xmlns:groupings="org.axiis.charts.groupings.*"
           xmlns:states="org.axiis.states.*" xmlns:scales="org.axiis.layouts.scale.*" xmlns:paint="org.axiis.paint.*"
           xmlns:labels="org.axiis.charts.labels.*">

  <!---  Data Provider used to feed the linear chart -->
  <mx:Object id="dataProvider"/>
  
  <mx:Number id="percentGap">.02
  </mx:Number>
  
  
  
  <mx:CurrencyFormatter precision="2" id="formatter0to10" alignSymbol="right" currencySymbol=""/>
  <mx:CurrencyFormatter precision="1" id="formatter10to100" alignSymbol="right" currencySymbol=""/>
  <mx:CurrencyFormatter precision="0" id="formatter100to10000" alignSymbol="right" currencySymbol=""
                        useThousandsSeparator="true"/>
  <mx:CurrencyFormatter currencySymbol="k" precision="0" id="formatter10000andOver" alignSymbol="right"
                        useThousandsSeparator="true"/>  
  
  <!--- 
  Vertical scale of the chart. It is where the values of the properties describing the record(s)
  are put on the chart.
  -->
  <scales:LinearScale id="vScale" dataProvider="{dataProvider}" minLayout="0" maxLayout="{myLineGroup.height}"/>
  <!--- 
  Horizontal scale of the graph. It is where the attributes describing the record(s) are put on the chart.
  -->
  <scales:CategoricalScale id="hScale" minLayout="0" maxLayout="{myLineGroup.width}"/>  
  
  <!---  FILLS &amp; STROKES -->
  
  <mx:Array id="palletsColors">
    <mx:uint>0xFFeb0810</mx:uint>
    <mx:uint>0xFFf5800b</mx:uint>
    <mx:uint>0xFFf4e601</mx:uint>
    <mx:uint>0xFFc6d816</mx:uint>
    <mx:uint>0xFF0c5e2c</mx:uint>
    <mx:uint>0xFF00a5d9</mx:uint>
    <mx:uint>0xFF581886</mx:uint>
    <mx:uint>0xFFab1057</mx:uint>
  </mx:Array>  
  
  <mx:Array id="textPalletsColors">
    <mx:uint>0xFF000000</mx:uint>
  </mx:Array>  
  
  <mx:Array id="palettes">
    <!--paint:LayoutAutoPalette id="outerPalette" layout="{myLineGroup}" colorFrom="0xCC3333" colorTo="0x3333CC"/>
    
    <paint:LayoutAutoPalette id="clusterPalette" layout="{myLineGroup}" colorFrom="{outerPalette.currentColor}"
    colorTo="{outerPalette.currentColor | 0x337f00}"/>
    
    <paint:LayoutAutoPalette id="areaPalette" layout="{myLineGroup}" colorFrom="0x3333CC" colorTo="0xCC3333"/-->
    
    <paint:LayoutPalette id="outerPalette" layout="{myLineGroup}" colors="{textPalletsColors}"/>
    
    <paint:LayoutPalette id="clusterPalette" layout="{myLineGroup}" colors="{palletsColors}"/>
    
    <paint:LayoutPalette id="areaPalette" layout="{myLineGroup}" colors="{palletsColors}"/>    
    
  </mx:Array>
  
  <mx:Array id="fills">
    <degrafa:LinearGradientFill id="areaFill" angle="90" enableEvents="false">
      <degrafa:GradientStop color="{areaPalette.currentColor}" alpha=".95"/>
      
      <degrafa:GradientStop color="{areaPalette.currentColor | 0x999933}" alpha=".65"/>
    </degrafa:LinearGradientFill>
    
    <degrafa:LinearGradientFill id="clusterFill" angle="45" enableEvents="false">
      <degrafa:GradientStop color="{clusterPalette.currentColor}"/>
      
      <degrafa:GradientStop color="{clusterPalette.currentColor | 0xFFFFFF}" alpha=".85"/>
    </degrafa:LinearGradientFill>
  </mx:Array>
  
  <mx:Array id="strokes">
    <degrafa:LinearGradientStroke id="colStroke" pixelHinting="true" angle="45" enableEvents="false">
      <degrafa:GradientStop color="0xFFFFFF" alpha=".7"/>
      
      <degrafa:GradientStop color="0xFFFFFF" alpha=".3"/>
    </degrafa:LinearGradientStroke>
    
    <degrafa:SolidStroke color="0xFFFFFF" alpha=".3"/>
    
    <degrafa:SolidStroke color="0x222222" id="axisStroke" pixelHinting="true"/>
    
    <degrafa:SolidStroke color="{areaPalette.currentColor}" id="myStroke" weight="1" alpha="1" caps="none"
                         pixelHinting="true"/>
  </mx:Array>  
  
  <!---
  The linear char is a component that displays record (numeric) attributes on a linear chart. 
  It is used to display the values of different attributes of a record description so that users 
  can easily compare the values of these comparable attributes.
  
  The main difference with the bar chart component is that the linear chart is used to compare 
  comparable attributes (remember that the bar chart can be used to compare any kind of attributes: 
  even if they are not really comparable together). The linear charts are normally used to compare 
  data in sequence: the same indicator over years; or the same indicate over ages (5 years old, 
  10 years old, etc.).
  
  Attributes are made comparable in the schema, and they are ordered according to their ordering 
  value, also defined in the schema used by the component, and use to describe target input records. 
  
  @author Frederick Giasson, Structured Dynamics LLC.
  -->
  <mx:Canvas creationComplete="init()" width="100%" height="100%" styleName="sLinearChart">
    <mx:Script>
      <![CDATA[
        import com.sd.semantic.core.Resultset;
        import com.sd.semantic.core.Schema;
        import com.sd.semantic.core.SchemaAttribute;
        import com.sd.semantic.core.Subject;
        import com.sd.semantic.events.*;
        import com.sd.semantic.settings.GeneralSettings;
        
        import mx.core.Application;
        
        import org.axiis.core.AxiisSprite;
        import org.axiis.data.DataSet;
        import org.axiis.events.LayoutItemEvent;
        import org.axiis.states.State;
        
        /** Core varibles shared amongst all semantic controls */
        
        /** 
         * Specifies that this component is a semantic component. If a component in a Flex application is a semantic
         * semantic component, this means that other semantic component can't behave differently depending of the "kind"
         * (semantic or not) of components that are present in the layout. This variable is just to specify is a component
         * is a semantic one or not.
         */
        public var semanticComponent:Boolean = true;
        
        /**
         * Specifies that this control is required within a display cluster.
         * This means that if we have a SemanticHBox that has 2 required semantic
         * components and that these components have removed themselves from the display
         * this means that the parent layout cluster (the smeantic hbox), will remove
         * itself as well. If a semantic component is marked as not required (required=false)
         * it means that it won't be considered by the semantic hbox. So, even if such a semantic
         * component has data in it, its parent cluster can remove itself.
         */
        public var required:Boolean = true;
        
        /** Target record attributes to display in the component */
        public var targetAttributes:Array = [];
        
        /** Target record types to display in the component */
        public var targetTypes:Array = [];
        
        /** Specifies if the sControl's targetAttribute has been bound to a know semantic control. */
        public var bound:Boolean = false;
        
        private var _semanticDataProvider:Resultset;
        
        /** Input records. This is a Resultset structure (see the structXML XML data structure) */
        public function get semanticDataProvider():Resultset
        {
          return (_semanticDataProvider);
        }
        
        public function set semanticDataProvider(value:Resultset):void
        {
          _semanticDataProvider = value;
          
          if(_initialized)
          {
            init();
          }
        }
        
        /** Specifies what attribute(s) of a record have been bound to this semantic component */
        public var boundAttributes:Array = [];
        
        /** Specifies if the component has already been initialized or not. */
        private var _initialized:Boolean = false;
        
        /** Axiis DataSet used to populate the Axiis components */
        private var ds:DataSet = new DataSet();
        
        /** Schema structure loaded for this semantic component */
        private var _schema:Schema = null;
        
        /** General Settings */
        private var generalSettings:GeneralSettings = null;
        
        /** Index of record selector column IDs and their bound record URIs */
        private var columnIdToRecordUri:Array = [];
        
        /** Base URL of the flex component */
        private var baseUrl:String = "./";
        
        /** Base URL of the flex component */
        private var settingsUrl:String = "./settings/";        
        
        /** 
         * Custom minimal value of the vertical scale of the control. This value will overwrite
         * the computed value of the scale.
         */
        public var custumVScaleMin:int = -1;
        
        /** 
         * Custom maximal value of the vertical scale of the control. This value will overwrite
         * the computed value of the scale.
         */
        public var custumVScaleMax:int = -1;        
        
        /** General settings of the semantic application */
        public function get schema():Schema
        {
          return (_schema);
        }
        
        public function set schema(value:Schema):void
        {
          this._schema = value;
        }
        
        /** Invalidate the bar chart to redraw it */
        public function invalidate():void
        {
          init();
        }
        
        public function setVerticalAxisLabel(label:String):void
        {
          this.verticalAxisLabel.changeLabel(label);
          this.verticalAxisLabel.visible = true;
          this.dc.invalidateProperties();
          this.dc.invalidateSize();
          this.dc.invalidateDisplayList();
          
          /** 
           * Set the changed vertical axis label in the parent sControl initializer object so that we
           * re-initilize the chart properly if the user switch between multiple controls.
           */
          if(!this.parent.parent.initializer["sLinearChart"])
          {
            this.parent.parent.initializer["sLinearChart"] = {};
          }
          
          this.parent.parent.initializer["sLinearChart"]["vAxisLabel"] = label;
        }
        
        public function getVerticalAxisLabel():String
        {
          return(this.verticalAxisLabel.labelValue);
        }
        
        /** Initialize the bar chart component */
        public function init():void
        {
          if(_semanticDataProvider != null)
          {
            /**
             * Load settings
             * 
             * Check if the application that embede this semantic component defined its 
             * baseAppUrl. If it didn't, we simply use the default local location "./"
             */
            
            /** Base URL of the flex component */
            if(Application.application.hasOwnProperty("baseAppUrl"))
            {
              if(Application.application.baseAppUrl != "")
              {
                baseUrl = Application.application.baseAppUrl;
              }
            } 
            else if(Application.application.parameters.baseAppUrl)
            {
              if(Application.application.parameters.baseAppUrl != "")
              {
                baseUrl = Application.application.parameters.baseAppUrl;
              }
            }
            
            if(Application.application.hasOwnProperty("settingsFolder"))
            {
              if(Application.application.settingsFolder != "")
              {
                settingsUrl = baseUrl + Application.application.settingsFolder;
              }
            } 
            
            dispatchEvent(new SemanticComponentLoadEvent("progress", {
              label: "Loading general settings for the linear chart control...",
              progress: 5
            }, true, false));            
            
            
            var settingsLoader:URLLoader = new URLLoader();
            settingsLoader.load(new URLRequest(settingsUrl + "General.xml"));
            settingsLoader.addEventListener(Event.COMPLETE, processSettingsHandler);
            
            /** Keep track of the attributes, from the record, that have been bound to this control. */
            if(targetAttributes.length > 0)
            {
              for each(var tAttr in targetAttributes)
              {
                boundAttributes.push(tAttr);
              }
            }        
          }
          
          _initialized = true;
        }
        
        /**
         * Get, parse and process the map settings 
         * 
         * @param event URLLoader success/failure event
         */    
        private function processSettingsHandler(event:Event):void
        {
          /** Check if there is any load/parsing error */
          var isError:Boolean = false;
          
          try
          { 
            /** Create the GeneralSettings class from the XML file */
            generalSettings = new GeneralSettings(new XML(event.target.data));
          }
          catch(error:Error)
          { 
            Alert.show("Can't load settings file '/settings/General.xml'. The linear chart tool won't be displayed." +
              "(" + error.message + ")");
            isError = true;
          }
          
          if(!isError)
          {
            if(generalSettings.error == true)
            {
              Alert.show("Required settings are missing in the settings file '/settings/General.xml'. The linear chart tool won't be displayed.");
              isError = true;
            }
          }
          
          /** If the setting file is properly loaded, we continue to process the bar chart component */      
          if(!isError)
          {
            dispatchEvent(new SemanticComponentLoadEvent("progress", {
              label: "General settings for the linear chart control loaded...",
              progress: 5
            }, true, false));               
            
            dispatchEvent(new SemanticComponentLoadEvent("completed", {
              label: "",
              progress: 100
            }, true, false));                  
            
            /** Intermediary data provider structure */
            var dataProviderFoo:Array = [];
            
            vScale.minValue = 0;		
            vScale.maxValue = 0;				
            
            /**
             * CSV data structure used to populate the linear graph.
             * 
             * The first column are the values used to populate the xAxis.
             * The other columns are the records composing the graph.
             * The values intersection of the rows (xAxis) and columns (records) are the values used
             * to create the lines in the linear graph
             * 
             * The structure looks like:
             * <pre>
             *   xAxis, record-1, record-2, record-3, ...
             *   1991,  10      , 12      , 34      , ...
             *   1996,  13      , 9       , 23      , ...
             *   ... ,  ...     , ...     , ...     , ...
             * </pre>
             */
            var csv:String = "xAxis,";
            
            /** 
             * Get all the attributes used for the xAxis.
             * 
             * These come from the targetAttributes list, and from all their "compatibleWith" related attributes.
             * 
             * Then, we use their "orderingValue" to populate the first column (xAxis).
             */
            
            /**
             * List of all comparableWith attributes that will be used to populate the linear graph.
             */
            var comparableAttributes:Array = [];
            
            for each(var predKey:String in targetAttributes)
            {
              /** a target attribute for this linear graph */
              var attribute:SchemaAttribute = this.schema.getAttribute(predKey);
              
              if(attribute)
              {
                /** Get all comparable attributes */
                var dump:Array = [];
                schema.getComparableAttributes(attribute.uri, dump);

                comparableAttributes = comparableAttributes.concat(dump);
                
//                /**
//                 * Get the parent attribute of the target attribute(s) (if existing) and add the entire list
//                 * of their children to the list of comparable attributes. Here the convention is that all
//                 * the sub-attributes of an attribute are comparable.
//                 */
//                var superAttributes:Array = schema.getSuperAttributes(attribute.uri);
//                
//                for each(var supera:SchemaAttribute in superAttributes)
//                {
//                  var subAttributes:Array = schema.getSubAttributes(supera.uri);
//                  
//                  for each(var suba:SchemaAttribute in subAttributes)
//                  {
//                    comparableAttributes = comparableAttributes.concat(suba);
//                  }
//                }
              }
            }  
            
            /**
             * Get all the other attributes, used to define the records of the resultset, that
             * share the same unitType as the target attributes.
             */
            
            /** Get the list of all the attributes defining all the records in the resultset */
//            var resultsetRecordsAttributes:Array = [];
//            
//            for each(var subject:Subject in this.semanticDataProvider.subjects)
//            {
//              for(var predicate:String in subject.predicates)
//              {
//                if(resultsetRecordsAttributes.indexOf(predicate) == -1)
//                {
//                  resultsetRecordsAttributes.push(predicate);
//                }
//              }
//            }            
            
            /** 
            * For each target attribute, we get the list of all the attributes that share the same
            * unitType.
            */
//            var attributesWithSameUnitType:Array = [];
//            
//            for each(var predKey:String in targetAttributes)
//            {
//              /** a target attribute for this linear graph */
//              var attribute:SchemaAttribute = this.schema.getAttribute(predKey);
//              
//              if(attribute)
//              {
//                var awsut:Array = [];
//                
//                schema.getSameUnitTypeAttributes(attribute.uri, awsut);
//                
//                for each(var att:SchemaAttribute in awsut)
//                {
//                  if(attributesWithSameUnitType.indexOf(att.uri) == -1)
//                  {
//                    attributesWithSameUnitType.push(att.uri);
//                  }
//                }
//              }
//            }
            
            /** 
            * We keep the attributes that share the same unitType and that are used to define the
            * records. All these attributes are considered comparable and are added to the
            * comparableOrderingValues array.
            */
            
//            for each(var a:String in resultsetRecordsAttributes)
//            {
//              if(attributesWithSameUnitType.indexOf(a) != -1 &&
//                comparableAttributes.indexOf(a) == -1)
//              {
//                comparableAttributes.push(this.schema.getAttribute(a));
//              }
//            }
            
            
            /** Ordering values used to populate the xAxis of the linear graph */  
            var comparableOrderingValues:Array = [];  
            
            /** 
             * Get the ordering value of the attribute. 
             * 
             * Internally, if there is none defined, the system simply used the 
             * prefLabel of the attribute, or event its URI as the ordering value
             */ 
            
            var bAttributes:Array = [];
            
            for each(var ca:SchemaAttribute in comparableAttributes)
            {
              if(bAttributes.indexOf(ca.uri) == -1) /** Remove duplicates */
              {
                comparableOrderingValues.push({uri: ca.uri, orderingValue: ca.orderingValue, shortLabel: ca.shortLabel});
                
                bAttributes.push(ca.uri);
              }
            }
            
            comparableOrderingValues.sortOn("orderingValue", Array.NUMERIC);
            
            /** Populate the columns with the prefLabel of the records */
            
            /** Keep track of the ID of the columns as they are created */
            var columnId = 1;
            
            for each(var subject:Subject in _semanticDataProvider.subjects)
            {
              var columnLabel:String = "";
              
              columnLabel = subject.getPrefLabel(this.document.generalSettings.prefLabelAttributes);
              columnLabel = columnLabel.replace(/,/g, " - ");
              
              csv = csv + columnLabel + ",";
              
              columnIdToRecordUri[columnId] = subject.uri;
              columnId++;
            }          
            
            /** replace the last "," by a new line */
            csv = csv.substr(0, csv.length - 1) + "\n";
            
            /** 
             * Create each row from the comparable attributes, and populate each of them
             * with the value of the attribute(s) for each of the records
             */
            for each(var attr:Object in comparableOrderingValues)
            {
              csv = csv + '"' + attr.shortLabel + '"' + ",";
              
              /** Get the value for the attribute for each record */
              for each(var subject:Subject in _semanticDataProvider.subjects)
              {
                var values:Array = subject.getPredicateValues(attr.uri);
                
                if(values && values.length > 0)
                {
                  csv = csv + '"' + values[0].value + '"' + ",";
                }
                else
                {
                  csv = csv + ",";
                }
              }
              
              /** replace the last "," by a new line */
              csv = csv.substr(0, csv.length - 1) + "\n";
            }
            
            ds.processCsvAsTable(csv, false);
            
            /**
             * LineSeriesGroup expects each unique series as a row
             * Since the first column is what is used as our X Axis (for example, temporal values) we want to 
             * pivot the data. This then makes a column for each unique time entrie and a row for each unique column.
             */
            ds.pivotTable(0);
            dataProvider = ds.data.pivot.rows;
            hScale.dataProvider=ds.data.pivot.header.slice(1, ds.data.pivot.header.length);
            hAxis.invalidateDataProvider();
            
            if(custumVScaleMin != -1)
            {
              vScale.minValue = custumVScaleMin;
            }
            
            if(custumVScaleMax != -1)
            {
              vScale.maxValue = custumVScaleMax;
            }
                        
            
            dc.invalidateDisplayList();
          }
          
          this.removeEventListener(Event.COMPLETE, processSettingsHandler);
        }         
        
        /** Format the attribute labels properly on the axis */
        private function axisLabel(obj:Object):String
        {
          if(Number(obj) < 10)
          {
            return(formatter0to10.format(Number(obj)));
          }
          else if(Number(obj) >= 10 && Number(obj) < 100)
          {
            return(formatter10to100.format(Number(obj)));
          }
          else if(Number(obj) >= 100 && Number(obj) < 10000)
          {
            return(formatter100to10000.format(Number(obj)));
          }
          else
          {
            return(formatter10000andOver.format(Number(obj) / 1000));
          }
        }
        
        /** Line mouse click event handler */    
        private function itemClickHandler(event:LayoutItemEvent):void
        {
          if(event.item.data)
          {
            /** Object to return composed of the prefLabel of the target record, and its URI */
            var record:Object = {prefLabel: event.item.data.pivotName, uri:columnIdToRecordUri[event.item.data.index]};
            
            /** Dispatch a bubbling item click event that will be catchable by the main application */
            dispatchEvent(new SemanticComponentItemEvent(SemanticComponentItemEvent.ITEM_CLICK, record, true));
          }
        }
        
        /** Line mouse over event handler */
        private function itemOverHandler(event:LayoutItemEvent):void
        {
          if(event.item.data)
          {
            /** Object to return composed of the prefLabel of the target record, and its URI */
            var record:Object = {prefLabel: event.item.data.pivotName, uri:columnIdToRecordUri[event.item.data.index]};
            
            /** Dispatch a bubbling item over event that will be catchable by the main application */
            dispatchEvent(new SemanticComponentItemEvent(SemanticComponentItemEvent.ITEM_OVER, record, true));
          }
        }  
        
        /** Line mouse out event handler */
        private function itemOutHandler(event:LayoutItemEvent):void
        {
          if(event.item.data)
          {
            /** Object to return composed of the prefLabel of the target record, and its URI */
            var record:Object = {prefLabel: event.item.data.prefLabel, uri: event.item.data.uri};
            
            /** Dispatch a bubbling item over event that will be catchable by the main application */
            dispatchEvent(new SemanticComponentItemEvent(SemanticComponentItemEvent.ITEM_OUT, record, true));
          }
        }
        
        /**
         * Select a target record in the component.
         * 
         * @param record Target subject record to be selected in the component. This object is expected to have
         *               a "uri" property that is used to find the record to select in the component.
         */
        public function selectRecord(record:Object):void
        {
          /** Make sure that the target record has the uri property defined */
          if(record.hasOwnProperty("uri"))
          {
            for(var columnId:String in columnIdToRecordUri)
            {
              /** find the column ID that match the target record URI */
              if(record.uri == columnIdToRecordUri[columnId])
              {
                /** find the state of the AxiisSprite that select a line region */
                if(myLineGroup.childSprites && myLineGroup.childSprites[columnId - 1] && myLineGroup.childSprites[columnId - 1].hasOwnProperty("states"))
                {
                  for each(var state:State in myLineGroup.childSprites[columnId - 1].states)
                  {
                    if(state.enterStateEvent == "mouseOver" && state.exitStateEvent == "mouseOut")
                    {
                      /** Lets remove all states of all AxiisSprite of this component */
                      for each(var childSprite:AxiisSprite in myLineGroup.childSprites)
                      {
                        childSprite.clearStates();
                      }
                      
                      /** We found the state we need to select the record. Now lets enable it */
                      myLineGroup.childSprites[columnId - 1].setState(state);
                      
                      break;
                    }
                  }
                }
                
                break;
              }
            }
          }      
        }    
        
        /**
         * Unselect all possible selected records in the chart
         */
        public function unselectRecords():void
        {
          /** Remove all states of all AxiisSprites of this component */
          for each(var childSprite:AxiisSprite in myLineGroup.childSprites)
          {
            childSprite.clearStates();
          }
        }    
        
        public function setVerticalScale(yMin:int, yMax:int):void
        {
          myLineGroup.autoAdjustScale = false;
          
          vScale.minValue = yMin;
          vScale.maxValue = yMax;
          
          custumVScaleMin = yMin;
          custumVScaleMax = yMax;
          
          /** 
           * Set the changed scales in the parent sControl initializer object so that we
           * re-initilize the chart properly if the user switch between multiple controls.
           */
          if(!this.parent.parent.initializer["sLinearChart"])
          {
            this.parent.parent.initializer["sLinearChart"] = {};
          }
          
          this.parent.parent.initializer["sLinearChart"]["vScaleMinValue"] = yMin;
          this.parent.parent.initializer["sLinearChart"]["vScaleMaxValue"] = yMax;          
          
          dc.invalidateDisplayList(); 
        }          
      ]]>
    </mx:Script>
    
    <!--- Linear Chart -->
    
    <!--- Canvas holding the chart lines -->
    <axiis:DataCanvas width="{this.width*.70}" id="dc" top="30" bottom="30" horizontalCenter="0" strokes="{strokes}"
                      fills="{fills}" palettes="{palettes}" showDataTips="true">
      <!--- Background of the chart -->
      <axiis:backgroundGeometries>
        <axis:VAxis id="vAxis" verticalScale="{vScale}" tickStroke="{axisStroke}" width="{dc.width}"
                    height="{myLineGroup.height}" showDataTips="false" fontFamily="Myriad Pro" fontColor="0" fontSize="14"
                    tickGap="5" majorTickSpacing="50" labelFunction="{axisLabel}"/>
        
        <axis:HCategoryAxis id="hAxis" x="{myLineGroup.x}" categoryScale="{this.hScale}" width="{myLineGroup.width}"
                            dataProvider="{hScale.dataProvider}" height="50" y="{myLineGroup.height}"/>
        
        <degrafa:Line x="0" x1="{myLineGroup.x+myLineGroup.width}" y="{myLineGroup.height}" y1="{myLineGroup.height}"
                      stroke="{axisStroke}"/>
        
        <labels:VLabel id="verticalAxisLabel"
                         height="{myLineGroup.height}"
                         width="15"
                         fontFamily="Myriad Pro"
                         fontSize="16"
                         fontColor="{outerPalette.currentColor}"
                         verticalCenter="1"
                         labelValue=""
                         x="-35" />        
      </axiis:backgroundGeometries>
      
      <!--- Layouts -->
      <axiis:layouts>
        <groupings:LineSeriesGroup id="myLineGroup" x="12" y="0" height="{dc.height-70}" width="{dc.width}"
                                   tension="0.2" markerColor="{areaPalette.currentColor}" showArea="false" markerSize="5" showMarker="false"
                                   mode="0" dataProvider="{dataProvider}" plotCollection="columns" dataField="value" labelField="pivotName"
                                   xDataField="name" plotLabelField="name" verticalScale="{vScale}" horizontalScale="{hScale}"
                                   stroke="{myStroke}" fill="{areaFill}"
                                   enableRollOver="true" itemClick="itemClickHandler(event)" itemMouseOver="itemOverHandler(event)"
                                   itemMouseOut="itemOutHandler(event)"/>
      </axiis:layouts>

    </axiis:DataCanvas>  
    
  </mx:Canvas>
  
</mx:Module>