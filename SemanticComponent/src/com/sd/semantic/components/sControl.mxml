<?xml version="1.0" encoding="utf-8"?>

<!---
  The bar char is a component that displays record (numeric) attributes on a bar chart. 
  It is used to display the values of different attributes of a record description so 
  that users can easily compare the values of these comparable attributes.
  
  Each bar on the graph is the value of a single attribute describing the target record 
  description. 
  
  @author Frederick Giasson, Structured Dynamics LLC.
-->

<mx:Box xmlns:mx="http://www.adobe.com/2006/mxml" width="100%" height="100%"
  styleName="sControl" clipContent="true">
  <mx:Script>
    <![CDATA[

    import com.sd.semantic.components.*;
    import com.sd.semantic.core.Resultset;
    import com.sd.semantic.core.Schema;
    import com.sd.semantic.core.SchemaAttribute;
    import com.sd.semantic.core.SchemaType;
    
    import mx.controls.Alert;
    import mx.controls.ComboBox;
    import mx.controls.Text;
    import mx.core.Application;

    /** Core varibles shared amongst all semantic controls */

    /** 
    * Specifies that this component is a semantic component. If a component in a Flex application is a semantic
    * semantic component, this means that other semantic component can't behave differently depending of the "kind"
    * (semantic or not) of components that are present in the layout. This variable is just to specify is a component
    * is a semantic one or not.
    */
    public var semanticComponent:Boolean = true;

    /**
    * Specifies that this control is required within a display cluster.
    * This means that if we have a SemanticHBox that has 2 required semantic
    * components and that these components have removed themselves from the display
    * this means that the parent layout cluster (the smeantic hbox), will remove
    * itself as well. If a semantic component is marked as not required (required=false)
    * it means that it won't be considered by the semantic hbox. So, even if such a semantic
    * component has data in it, its parent cluster can remove itself.
    */
    public var required:Boolean = true;

    /**
    * The recordBox attribute specifies if the HBox contains all the controls
    * to display information about a complete record. This mainly used
    * to manage the "GenericBox" generic content attribute display control.
    */
    public var recordBox:Boolean = false;

    /** Target record attributes to display in the component */
    public var targetAttributes:Array = [];

    /** Target record types to display in the component */
    public var targetTypes:Array = [];
    
    /** Target records to display in the component */
    public var targetRecords:Array = [];
    
    /** Specifies if the sControl's targetAttribute has been bound to a know semantic control. */
    public var bound:Boolean = false;

    /** Specifies if the control as already been initialized. */
    private var isInitialized:Boolean = false;
    
    private var _semanticDataProvider:Resultset;
    
    /** Input records. This is a Resultset structure (see the structXML XML data structure) */
    public function get semanticDataProvider():Resultset
    {
      return (_semanticDataProvider);
    }      

    /** Other variables */

    /** Schema structure used to select the proper component for the input records, target attributes and types. */
    public var schema:Schema;

    private var viewSwitcher:ComboBox = new ComboBox();      
      
    public function set semanticDataProvider(value:Resultset):void
    {
      _semanticDataProvider = value;

      /** Make sure it has been initialized a first time*/
      if(isInitialized)
      {
        /**
        *  If the semanticDataProvider of the sControl changes, we have to
        *  reflect these changes to the children control(s) as well!
        */

        /** Children components of the sControl */
        var children:Array = this.getChildren();

        for each(var child:Object in children)
        {
          if(child is sRelationBrowser)
          {
            child.semanticDataProvider = _semanticDataProvider;
            child.targetAttributes = targetAttributes;
            child.targetTypes = targetTypes;
            child.schema = schema;
          }
 
          if(child is sStory)
          {
            child.semanticDataProvider = _semanticDataProvider;
            child.targetAttributes = targetAttributes;
            child.targetTypes = targetTypes;
            child.schema = schema;
          }
          
          if(child is sDashboard)
          {
            child.semanticDataProvider = _semanticDataProvider;
            child.targetAttributes = targetAttributes;
            child.targetTypes = targetTypes;
            child.targetRecords = targetRecords;
            child.schema = schema;
          }
          
          if(child is sMap)
          {
            child.semanticDataProvider = _semanticDataProvider;
            child.targetAttributes = targetAttributes;
            child.targetTypes = targetTypes;
          }
          
          if(child is sWebMap)
          {
            child.semanticDataProvider = _semanticDataProvider;
            child.targetAttributes = targetAttributes;
            child.targetTypes = targetTypes;
          }
          
          if(child is sBarChart)
          {
            child.semanticDataProvider = _semanticDataProvider;
            child.targetAttributes = targetAttributes;
            child.targetTypes = targetTypes;
            child.schema = schema;
          }

          if(child is sLinearChart)
          {
            child.semanticDataProvider = _semanticDataProvider;
            child.targetAttributes = targetAttributes;
            child.targetTypes = targetTypes;
            child.schema = schema;
          }

          if(child is sText)
          {
            child.text = _semanticDataProvider[targetAttributes[0]];
          }

          if(child is sImage)
          {
            child.semanticSource = "[[" + targetAttributes[0] + "]]";
            child.semanticDataProvider = _semanticDataProvider;
          }
        }
      }
    }

    /**
     * Initialization function ran once the application's creation is complete. It selects the proper semantic
     * component(s) to embed in the sControl canvas.
     * 
     * Because of the life cycle of the Flex components, we don't have access to the properties when we call
     * createChildren(). It is for that reason that we have to do this initialization at the level of the
     * commitProperties() function.
     * 
     * This is because we are not using Flex they way they intend us to use it. Normally, we know what
     * component we want to create. Here, the component we want to create is based on schema and targetAttributes
     * properties that will "initialize" the component, and that will have a major impact on the 
     * child component(s) created by the sControl component.
     */
    override protected function commitProperties():void
    {
      /** Call the createChildren() method of the superclass. */
      super.commitProperties();
      
      if(isInitialized == false)
      {
        /** 
        * All controls that can be used to display information about a record or a set of records.
        * Each of these control can be seen as a different view to look at the data describing a
        * record or a group of records.
        */
        var displayControls:Array = new Array();
  
        if(schema)
        {
          for each(var tAttribute:String in targetAttributes)
          {
            targetAttribute = schema.getAttribute(tAttribute);
    
            if(targetAttribute != null)
            {
              for each(var control:String in targetAttribute.displayControls)
              {
                if(displayControls.indexOf(control) == -1)
                {
                  displayControls.push(control);
                }
              }
            }
          }
    
          for each(var tType:String in targetTypes)
          {
            targetType = schema.getType(tType);
    
            if(targetType != null)
            {
              for each(var control:String in targetType.displayControls)
              {
                if(displayControls.indexOf(control) == -1)
                {
                  displayControls.push(control);
                }
              }
            }
          }
        }
  
        /** 
        * Array of objects pointing to created controls
        * 
        * Objects are of the type: {prefLabel: ..., control: ..., controlName: ...}
        */
        var switchableControls:Array = new Array();
  
        for each(var displayControl:String in displayControls)
        {
          switch(displayControl)
          {
            case "sRelationBrowser":
            {
              if(bound == false)
              {
                this.createControl(displayControl);
                switchableControls.push({prefLabel: "Relation Browser view", control: this.getChildAt(0),
                  controlName:displayControl});
              }
              else
              {
                switchableControls.push({prefLabel: "Relation Browser view", control: null, controlName:displayControl});
              }
  
              bound = true;
            }
            break;
            
            case "sStory":
            {
              if(bound == false)
              {
                this.createControl(displayControl);
                switchableControls.push({prefLabel: "Story view", control: this.getChildAt(0),
                  controlName:displayControl});
              } 
              else
              {
                switchableControls.push({prefLabel: "Story view", control: null, controlName:displayControl});
              }
              
              bound = true;
            }
              break;
            
            case "sDashboard":
            {
              if(bound == false)
              {
                this.createControl(displayControl);
                switchableControls.push({prefLabel: "Dashboard", control: this.getChildAt(0),
                  controlName:displayControl});
              } 
              else
              {
                switchableControls.push({prefLabel: "Dashboard", control: null, controlName:displayControl});
              }
              
              bound = true;
            }
            break;
            
            case "sMap":
            {
              if(bound == false)
              {
                this.createControl(displayControl);
                switchableControls.push({prefLabel: "Map view", control: this.getChildAt(0), controlName:displayControl});
              }
              else
              {
                switchableControls.push({prefLabel: "Map view", control: null, controlName:displayControl});
              }
              
              bound = true;
            }
            break;
            
            case "sWebMap":
            {
              if(bound == false)
              {
                this.createControl(displayControl);
                switchableControls.push({prefLabel: "Web Map view", control: this.getChildAt(0), controlName:displayControl});
              }
              else
              {
                switchableControls.push({prefLabel: "Web Map view", control: null, controlName:displayControl});
              }
              
              bound = true;
            }
            break;
            
            case "sBarChart":
            {
              if(bound == false)
              {
                this.createControl(displayControl);
                switchableControls.push({prefLabel: "Bar Chart view", control: this.getChildAt(0),
                  controlName:displayControl});
              }
              else
              {
                switchableControls.push({prefLabel: "Bar Chart view", control: null, controlName:displayControl});
              }
  
              bound = true;
            }
            break;
            case "sLinearChart":
            {
              if(bound == false)
              {
                this.createControl(displayControl);
                switchableControls.push({prefLabel: "Linear Chart view", control: this.getChildAt(0),
                  controlName:displayControl});
              }
              else
              {
                switchableControls.push({prefLabel: "Linear Chart view", control: null, controlName:displayControl});
              }
  
              bound = true;
            }
            break;
  
            case "sImage":
            {
              if(bound == false)
              {
                this.createControl(displayControl);
                switchableControls.push({prefLabel: "Image view", control: this.getChildAt(0),
                  controlName:displayControl});
              }
              else
              {
                switchableControls.push({prefLabel: "Image view", control: null, controlName:displayControl});
              }
  
              bound = true;
            }
            break;
          }
        }
  
        /**
        * If we have multiple controls for that target sControl, lets create a combobox
        * that will enable users to switch between views.
        */
  
        if(displayControls.length > 1)
        {
          /** 
          * Switch from a control to another if a target sControl has more than one displayControl associated
          * to it.
          */
          viewSwitcher.height = 15;
          viewSwitcher.width = 150;
          viewSwitcher.x = 5;
          viewSwitcher.y = this.y - 20;
          viewSwitcher.visible = true;
  
          viewSwitcher.dataProvider = switchableControls;
          viewSwitcher.labelField = "prefLabel";
  
          viewSwitcher.addEventListener(Event.CHANGE, switchView);
  
          /** make the first control visible in the sControl */
          if(selectControl == "")
          {
            switchableControls[0].control.visible = true;
          }
          else
          {
            var selectItem:int = 0;
            
            for each(var ctrl:Object in switchableControls)
            {
              if(ctrl.controlName == selectControl && selectItem > 0)
              {
                /** Delete the visible control */
                if(switchableControls[0].control != null)
                {
                  switchableControls[0].control.parent.removeChild(switchableControls[0].control);
                  switchableControls[0].control = null;
                }
                
                /** Create the new control */
                this.createControl(selectControl);
                switchableControls[selectItem].control = this.getChildAt(0);
                
                viewSwitcher.selectedIndex = selectItem;
                
                break;
              }
              
              selectItem++;
            }
          }
  
          this.addChild(viewSwitcher);
        }
  
        if(!bound)
        {
          if(_semanticDataProvider != null && targetAttributes.length > 0)
          {
            /** If no displayControl is defined, we simply display the value as text. */
            
            this.createControl("sText");
          }
        }
  
        isInitialized = true;
      }
    }

    /**
    * Create and embed a semantic control in the sControl canvas.
    * 
    * @param control kind of semantic control to be created
    */
    private function createControl(control:String):void
    {
      switch(control)
      {
        case "sRelationBrowser":
        {
          var controlRelationBrowser:sRelationBrowser = new sRelationBrowser();
          controlRelationBrowser.semanticDataProvider = _semanticDataProvider;
          controlRelationBrowser.targetAttributes = targetAttributes;
          controlRelationBrowser.targetTypes = targetTypes;
          controlRelationBrowser.schema = schema;

          this.addChildAt(controlRelationBrowser, 0);

          /** Set the main styleName of the semantic component to this parent sControl */
          if(StyleManager.getStyleDeclaration(".sRelationBrowser"))
          {
            this.styleName = "sRelationBrowser";
          }
        }
        break;
        case "sStory":
        {
          var controlStory:sStory = new sStory();
          controlStory.semanticDataProvider = _semanticDataProvider;
          controlStory.targetAttributes = targetAttributes;
          controlStory.targetTypes = targetTypes;
          controlStory.schema = schema;
          
          this.addChildAt(controlStory, 0);
          
          /** Set the main styleName of the semantic component to this parent sControl */
          if(StyleManager.getStyleDeclaration(".sStory"))
          {
            this.styleName = "sStory";
          }
        }
        break;
        case "sDashboard":
        {
          var controlDashboard:sDashboard = new sDashboard();
          controlDashboard.targetAttributes = targetAttributes;
          controlDashboard.targetTypes = targetTypes;
          controlDashboard.targetRecords = targetRecords;
          controlDashboard.schema = schema;
          controlDashboard.semanticDataProvider = _semanticDataProvider;
          
          this.addChildAt(controlDashboard, 0);
          
          /** Set the main styleName of the semantic component to this parent sControl */
          if(StyleManager.getStyleDeclaration(".sDashboard"))
          {
            this.styleName = "sDashboard";
          }
        }
        break;
        case "sMap":
        {
          var controlMap:sMap = new sMap();
          controlMap.semanticDataProvider = _semanticDataProvider;
          controlMap.targetAttributes = targetAttributes;
          controlMap.targetTypes = targetTypes;
          
          this.addChildAt(controlMap, 0);
          
          /** Set the main styleName of the semantic component to this parent sControl */
          if(StyleManager.getStyleDeclaration(".sMap"))
          {
            this.styleName = "sMap";
          }
        }
        break;
        case "sWebMap":
        {
          var controlWebMap:sWebMap = new sWebMap();
          controlWebMap.semanticDataProvider = _semanticDataProvider;
          controlWebMap.targetAttributes = targetAttributes;
          controlWebMap.targetTypes = targetTypes;
          
          this.addChildAt(controlWebMap, 0);
          
          /** Set the main styleName of the semantic component to this parent sControl */
          if(StyleManager.getStyleDeclaration(".sWebMap"))
          {
            this.styleName = "sWebMap";
          }
        }
        break;
        case "sBarChart":
        {
          var controlBarChart:sBarChart = new sBarChart();
          controlBarChart.percentHeight = 100;
          controlBarChart.percentWidth = 100;
          controlBarChart.semanticDataProvider = _semanticDataProvider;
          controlBarChart.targetAttributes = targetAttributes;
          controlBarChart.targetTypes = targetTypes;
          controlBarChart.schema = schema;
          
          this.addChildAt(controlBarChart, 0);

          /** Set the main styleName of the semantic component to this parent sControl */
          if(StyleManager.getStyleDeclaration(".sBarChart"))
          {
            this.styleName = "sBarChart";
          }
        }
        break;
        case "sLinearChart":
        {
          var controlLinearChart:sLinearChart = new sLinearChart();
          controlLinearChart.percentHeight = 100;
          controlLinearChart.percentWidth = 100;
          controlLinearChart.semanticDataProvider = _semanticDataProvider;
          controlLinearChart.targetAttributes = targetAttributes;
          controlLinearChart.targetTypes = targetTypes;
          controlLinearChart.schema = schema;

          this.addChildAt(controlLinearChart, 0);

          /** Set the main styleName of the semantic component to this parent sControl */
          if(StyleManager.getStyleDeclaration(".sLinearChart"))
          {
            this.styleName = "sLinearChart";
          }
        }
        break;
        
        case "sImage":
        {
          var controlImage:sImage = new sImage();
          controlImage.semanticDataProvider = _semanticDataProvider;
          controlImage.targetAttributes = targetAttributes;
          controlImage.targetTypes = targetTypes;
          controlImage.semanticSource = "[[" + targetAttributes[0] + "]]";
          
          this.addChildAt(controlImage, 0);
          
          /** Set the main styleName of the semantic component to this parent sControl */
          if(StyleManager.getStyleDeclaration(".sImage"))
          {
            this.styleName = "sImage";
          }
        }
        break;
        
        case "sText":
        {
          var controlText:sText = new sText();
          controlText.semanticDataProvider = _semanticDataProvider;
          controlText.targetAttributes = targetAttributes;
          controlText.targetTypes = targetTypes;
          controlText.percentHeight = 100;
          controlText.percentWidth = 100;          

          this.addChildAt(controlText, 0);
          
          /** Set the main styleName of the semantic component to this parent sControl */
          if(StyleManager.getStyleDeclaration(".sText"))
          {
            this.styleName = "sText";
          }
        }
        break;
      }
    }

    /**
    * Switch from a semantic component to another for the same sControl canvas. This only happens
    * if multiple semantic component can be used to display information about the same records, target
    * attributes and target types.
    */
    private function switchView(event:Event):void
    {
      /** Delete the visible control */
      for each(var control:Object in event.target.dataProvider)
      {
        if(control.control != null)
        {
          control.control.parent.removeChild(control.control);
          control.control = null;
          break;
        }
      }

      /** Create the new control */
      this.createControl(event.target.dataProvider[event.target.selectedIndex].controlName);
      event.target.dataProvider[event.target.selectedIndex].control = this.getChildAt(0);
    }
      
    /**
    * Select a specific control within the list of available controls that can be used to
    * display information about the input records.
    */
    public var selectControl:String = "";

    ]]>
  </mx:Script>
</mx:Box>