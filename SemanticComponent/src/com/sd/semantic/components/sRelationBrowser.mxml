<?xml version = "1.0" encoding = "utf-8"?>

<!---
  The relation browser is a component that displays networks of nodes and arcs. 
  It is usually used to display conceptual structures described in irXML. These 
  irXML schemas are themselves generally created from OWL2 ontologies, or are 
  directly created in irXML.
  
  Each node in the relation browser is a concept, and each arc is a relationship 
  between two concept nodes. The relationship can be one of sub-concept or one of 
  super-concept.
  
  Additionally this relation browser tool can related records of different type
  related to each focused node. 
  
  @author Frederick Giasson (updater), Structured Dynamics LLC.
  @author Moritz Stefaner (initial creator), http://moritz.stefaner.eu
  
  Initial copyrights: Copyright 2010, Moritz Stefaner (http://moritz.stefaner.eu) 
-->
<mx:Canvas xmlns:mx = "http://www.adobe.com/2006/mxml" creationComplete = "init()" width="100%" height="100%" xmlns:etc="org.etc.*">
  <mx:Script>
    <![CDATA[
      import com.sd.semantic.core.*;
      import com.sd.semantic.settings.GeneralSettings;
      import com.sd.semantic.settings.RelationBrowserSettings;
      
      import eu.stefaner.flareextensions.render.StairStepEdgeRenderer;
      import eu.stefaner.relationbrowser.RelationBrowser;
      import eu.stefaner.relationbrowser.data.AtomicNode;
      import eu.stefaner.relationbrowser.data.EdgeSkin;
      import eu.stefaner.relationbrowser.data.NodeData;
      import eu.stefaner.relationbrowser.data.NodeSkin;
      import eu.stefaner.relationbrowser.data.SkinsManager;
      import eu.stefaner.relationbrowser.encoders.Encoders;
      import eu.stefaner.relationbrowser.layout.*;
      import eu.stefaner.relationbrowser.ui.Edge;
      import eu.stefaner.relationbrowser.ui.Node;
      
      import flare.scale.ScaleType;
      import flare.util.Shapes;
      import flare.util.palette.ColorPalette;
      import flare.vis.data.Data;
      import flare.vis.data.render.ArrowType;
      import flare.vis.operator.Operator;
      import flare.vis.operator.encoder.ColorEncoder;
      
      import flash.events.Event;
      import flash.external.*;
      import flash.external.ExternalInterface;
      import flash.filters.DropShadowFilter;
      import flash.geom.Rectangle;
      
      import mx.collections.ArrayCollection;
      import mx.containers.HBox;
      import mx.controls.Alert;
      import mx.controls.Label;
      import mx.controls.Text;
      import mx.controls.TextArea;
      import mx.core.Application;
      import mx.events.ItemClickEvent;
      import mx.events.ListEvent;
      import mx.rpc.events.FaultEvent;
      import mx.rpc.events.ResultEvent;
      import mx.rpc.http.HTTPService;
      import mx.utils.ObjectUtil;
      
      import org.etc.BreadcrumbNavigator;
      
      
      /** Core varibles shared amongst all semantic controls */
      
      /** 
       * Specifies that this component is a semantic component. If a component in a Flex application is a semantic
       * semantic component, this means that other semantic component can't behave differently depending of the "kind"
       * (semantic or not) of components that are present in the layout. This variable is just to specify is a component
       * is a semantic one or not.
       */
      public var semanticComponent:Boolean = true;
      
      /**
       * Specifies that this control is required within a display cluster.
       * This means that if we have a SemanticHBox that has 2 required semantic
       * components and that these components have removed themselves from the display
       * this means that the parent layout cluster (the smeantic hbox), will remove
       * itself as well. If a semantic component is marked as not required (required=false)
       * it means that it won't be considered by the semantic hbox. So, even if such a semantic
       * component has data in it, its parent cluster can remove itself.
       */
      public var required:Boolean = true;
      
      /**
       * The recordBox attribute specifies if the HBox contains all the controls
       * to display information about a complete record. This mainly used
       * to manage the "GenericBox" generic content attribute display control.
       */
      public var recordBox:Boolean = false;
      
      /** Target record attributes to display in the component */
      public var targetAttributes:Array = [];
      
      /** Target record types to display in the component */
      public var targetTypes:Array = [];     
      
      /** Specifies if the sControl's targetAttribute has been bound to a know semantic control. */
      public var bound:Boolean = false;
      
      private var _semanticDataProvider:Resultset;
      
      /** Input records. This is a Resultset structure (see the structXML XML data structure) */
      public function get semanticDataProvider():Resultset
      {
        return (_semanticDataProvider);
      }      
      
      public function set semanticDataProvider(value:Resultset):void
      {
        _semanticDataProvider = value;
        
        targetRecordResultset = _semanticDataProvider;
        targetRecordURI = targetRecordResultset.subjects[0].uri;
      }    
      
      /** Target record being manipulated */
      private var targetRecordResultset:Resultset = null;

      /** The URI of the target record (selected node) being processed */
      private var targetRecordURI:String = "";
      
      /** The actual breadcrumb path. Each item of the array is the the URI of a visited node in chronological order. */
      [Bindable] private var breadcrumbPath:ArrayCollection = new ArrayCollection([]);
      
      /** The skin manager for nodes and edges */
      public var skinsManager:SkinsManager = new SkinsManager();
      
      /** Other variables */      

      private var _schema:Schema;
      
      /** 
       * Schema used to create the nodes of the graph to be displayed in the relation browser. Each type
       * will become a node, and each subClassOf relationship will become a sub-concept/super-concept 
       * relationship between two nodes in the graph.
       * 
       * This is a irXML schema.
       */ 
      public function get schema():Schema
      {
        return (_schema);
      }
      
      public function set schema(value:Schema):void
      {
        this._schema = value;
      }

      /** Specifies what attribute(s) of a record have been bound to this semantic component */
      public var boundAttributes:Array = [];      
      
      /** Relation browser object that display the network of concepts */
      protected var relationBrowser:RelationBrowser;

      /** Relation browser settings */
      private var settings:RelationBrowserSettings;

      /** General Settings */
      private var generalSettings:GeneralSettings = null;
      
      /** Specifies if the relation browser has been initialized */
      private var _initialized:Boolean = false;

      /** Determine is the exporer is loaded or not */
      private var isLoadCompleted:Boolean = false;
      
      /** List of hidden nodes */
      public var hiddenNodes:Array = [];
      
      /** List of hidden edges */
      public var hiddenEdges:Array = [];      
      
      /** List of removed edges */
      public var removedNodes:Array = [];

      /** List of removed edges */
      public var removedEdges:Array = [];      
      
      /** Target node ID that is currently selected in the user interface */
      //private var targetType:SchemaType;
  
      /** Invalidate the map to redraw it */
      public function invalidate():void
      {
        init();
      }
  
      /** Initialize the relation browser component */
      private function init():void
      {
        /**
         * Load settings
         * 
         * Check if the application that embede this semantic component defined its 
         * baseAppUrl. If it didn't, we simply use the default local location "./"
         */
        
        /** Base URL of the flex component */
        var baseUrl:String = "./";
        
        if(Application.application.hasOwnProperty("baseAppUrl"))
        {
          if(Application.application.baseAppUrl != "")
          {
            baseUrl = Application.application.baseAppUrl;
          }
        } 
        else if(Application.application.parameters.baseAppUrl)
        {
          if(Application.application.parameters.baseAppUrl != "")
          {
            baseUrl = Application.application.parameters.baseAppUrl;
          }
        }
        
        var generalSettingsLoader:URLLoader = new URLLoader();
        
        generalSettingsLoader.load(new URLRequest(baseUrl + "settings/General.xml"));
        generalSettingsLoader.addEventListener(Event.COMPLETE, processGeneralSettingsHandler);               
         
        /** Keep track of the attributes, from the record, that have been bound to this control. */
        if(targetAttributes.length > 0)
        {
          for each(var tAttr in targetAttributes)
          {
            boundAttributes.push(tAttr);
          }
        }        
      }
      
      /**
       * Get, parse and process the general settings 
       * 
       * @param event URLLoader success/failure event
       */    
      private function processGeneralSettingsHandler(event:Event):void
      {
        /** Check if there is any load/parsing error */
        var isError:Boolean = false;
        
        try
        { 
          /** Create the GeneralSettings class from the XML file */
          generalSettings = new GeneralSettings(new XML(event.target.data));
        }
        catch(error:Error)
        { 
          Alert.show("Can't load settings file '/settings/General.xml'. The linear chart tool won't be displayed." +
                     "(" + error.message + ")");
          isError = true;
        }
        
        if(!isError)
        {
          if(generalSettings.error == true)
          {
            Alert.show("Required settings are missing in the settings file '/settings/General.xml'. The linear chart tool won't be displayed.");
            isError = true;
          }
        }
        
        /** If the setting file is properly loaded, we continue to process the bar chart component */      
        if(!isError)
        {
          /** Base URL of the flex component */
          var baseUrl:String = "./";
          
          if(Application.application.hasOwnProperty("baseAppUrl"))
          {
            if(Application.application.baseAppUrl != "")
            {
              baseUrl = Application.application.baseAppUrl;
            }
          } 
          else if(Application.application.parameters.baseAppUrl)
          {
            if(Application.application.parameters.baseAppUrl != "")
            {
              baseUrl = Application.application.parameters.baseAppUrl;
            }
          }        
          
          /** URL Loader for the map settings file */
          var settingsLoader:URLLoader = new URLLoader();
          
          settingsLoader.load(new URLRequest(baseUrl + "settings/sRelationBrowser.xml"));
          settingsLoader.addEventListener(Event.COMPLETE, processSettingsHandler); 
        }
      }

      
      /**
       * Get, parse and process the map settings 
       * 
       * @param event URLLoader success/failure event
       */
      private function processSettingsHandler(event:Event):void
      {
        var isError:Boolean = false;
        
        try
        { 
          /** Generate a settings class instance from the XML settings file */
          settings = new RelationBrowserSettings(new XML(event.target.data));
        }
        catch(error:Error)
        { 
          Alert.show("Can't load settings file '/settings/sRelationBrowser.xml'. The map tool won't be displayed." +
                     "(" + error.message + ")");
          isError = true;
        }
         
        if(!isError)
        { 
          if(settings.error == true)
          {
            Alert.show("Required settings are missing in the settings file '/settings/sRelationBrowser.xml'. The map tool won't be displayed.");
            isError = true;
          }
        }
          
        /** If we don't have any error, we continue the initialization of the relation browser */
        if(!isError)
        {
          /** Base URL of the flex component */
          var baseUrl:String = "./";
          
          if(Application.application.hasOwnProperty("baseAppUrl"))
          {
            if(Application.application.baseAppUrl != "")
            {
              baseUrl = Application.application.baseAppUrl;
            }
          } 
          else if(Application.application.parameters.baseAppUrl)
          {
            if(Application.application.parameters.baseAppUrl != "")
            {
              baseUrl = Application.application.parameters.baseAppUrl;
            }
          }            
          
          var skinsLoader:URLLoader = new URLLoader();
          
          skinsLoader.load(new URLRequest(baseUrl + "settings/sRelationBrowserSkins.xml"));
          skinsLoader.addEventListener(Event.COMPLETE, processSkinsHandler);               
          
//          startUp();
        }
        
        this.removeEventListener(Event.COMPLETE, processSettingsHandler);
      }
      
      /**
       * Get, parse and process the nodes & edges skin XML file.
       * 
       * @param event URLLoader success/failure event
       */
      private function processSkinsHandler(event:Event):void
      { 
        var skin:XML = XML(event.target.data);
        
        
        /** Get nodes skins */
        for each(var node:XML in skin.nodes.node)
        {
          var nodeSkin:NodeSkin = new NodeSkin(node.@type.toString());
            
          if(node.@uri != undefined)
          {
            nodeSkin.uri = node.@uri.toString();
          }
          
          if(node.tooltips != undefined)
          {
            if(node.tooltips.toString().toLocaleLowerCase() == "true")
            {
              nodeSkin.tooltips = true; 
            }
            else
            {
              nodeSkin.tooltips = false; 
            }
          }
          
          if(node.automaticCentering != undefined)
          {
            if(node.automaticCentering.toString().toLocaleLowerCase() == "true")
            {
              nodeSkin.automaticCentering = true; 
            }
            else
            {
              nodeSkin.automaticCentering = false; 
            }
          }          
          
          if(node.image != undefined)
          {
            nodeSkin.image = node.image.toString(); 
          }
          
          if(node.imageSelected != undefined)
          {
            nodeSkin.imageSelected = node.imageSelected.toString(); 
          }
          
          if(node.label != undefined)
          {
            nodeSkin.label = node.label.toString(); 
          }
          
          if(node.shape != undefined)
          {
            nodeSkin.shape = node.shape.toString(); 
          }
          
          if(node.lineWeight != undefined)
          {
            nodeSkin.lineWeight = int(node.lineWeight.toString()); 
          }
          
          if(node.lineColor != undefined)
          {
            nodeSkin.lineColor = uint(node.lineColor.toString()); 
          }
          
          if(node.fillColor != undefined)
          {
            nodeSkin.fillColor = uint(node.fillColor.toString()); 
          }
          
          if(node.textColor != undefined)
          {
            nodeSkin.textColor = uint(node.textColor.toString()); 
          }
          
          if(node.textFont != undefined)
          {
            nodeSkin.textFont = node.textFont.toString(); 
          }
          
          if(node.radius != undefined)
          {
            nodeSkin.radius = int(node.radius.toString()); 
          }
          
          if(node.textSize != undefined)
          {
            nodeSkin.textSize = int(node.textSize.toString()); 
          }
          
          if(node.backgroundScaleFactor != undefined)
          {
            nodeSkin.backgroundScaleFactor = Number(node.backgroundScaleFactor.toString()); 
          }       
          
          if(node.textScaleFactor != undefined)
          {
            nodeSkin.textScaleFactor = Number(node.textScaleFactor.toString()); 
          }   
          
          if(node.textOffsetX != undefined)
          {
            nodeSkin.textOffsetX = int(node.textOffsetX.toString()); 
          }
          
          if(node.textOffsetY != undefined)
          {
            nodeSkin.textOffsetY = int(node.textOffsetY.toString()); 
          }
          
          if(node.textMaxWidth != undefined)
          {
            nodeSkin.textMaxWidth = int(node.textMaxWidth.toString()); 
          }
          
          if(node.textMaxHeight != undefined)
          {
            nodeSkin.textMaxHeight = int(node.textMaxHeight.toString()); 
          }
          
          if(node.overNodeColorOverlay != undefined)
          {
            var value:String = node.overNodeColorOverlay.toString()
            value = value.replace(/^\[/, "").replace(/\]$/, "");
            
            if(value == "")
            {
              nodeSkin.overNodeColorOverlay = [0, 0, 0, 0];  
            }
            else
            {
              nodeSkin.overNodeColorOverlay = value.split(/\s*,\s*/);
            }
          }
          
          if(node.selectedNodeColorOverlay != undefined)
          {
            var value:String = node.selectedNodeColorOverlay.toString()
            value = value.replace(/^\[/, "").replace(/\]$/, "");
            
            if(value == "")
            {
              nodeSkin.selectedNodeColorOverlay = [0, 0, 0, 0];  
            }
            else
            {
              nodeSkin.selectedNodeColorOverlay = value.split(/\s*,\s*/);
            }
          }
          
          if(node.textMultilines != undefined)
          {
            if(node.textMultilines.toString().toLocaleLowerCase() == "true")
            {
              nodeSkin.textMultilines = true; 
            }
            else
            {
              nodeSkin.textMultilines = false; 
            }
          }          
          
          skinsManager.addNodeSkin(nodeSkin);
        }

        /** Get atomic nodes skins */
        for each(var anode:XML in skin.atomicNodes.node)
        {
          var atomicNode:AtomicNode = new AtomicNode(anode.@uri.toString());
          
          if(anode.actionClickGoto != undefined)
          {
            atomicNode.actionClickGoto = anode.actionClickGoto.toString();
          }
          
          skinsManager.addAtomicNode(atomicNode);
        }
        
        skinsManager.addNodeSkin(nodeSkin);        
        
        /** Get edges skins */
        for each(var edge:XML in skin.edges.edge)
        {
          var edgeSkin:EdgeSkin = new EdgeSkin(edge.@type.toString());
          
          if(edge.image != undefined)
          {
            edgeSkin.image = edge.image.toString(); 
          }
          
          if(edge.lineWeight != undefined)
          {
            edgeSkin.lineWeight = int(edge.lineWeight.toString()); 
          }
          
          if(edge.lineColor != undefined)
          {
            edgeSkin.lineColor = uint(edge.lineColor.toString()); 
          }
          
          if(edge.textColor != undefined)
          {
            edgeSkin.textColor = uint(edge.textColor.toString()); 
          }
          
          if(edge.textFont != undefined)
          {
            edgeSkin.textFont = edge.textFont.toString(); 
          }
          
          if(edge.textSize != undefined)
          {
            edgeSkin.textSize = int(edge.textSize.toString()); 
          }
          
          if(edge.directedArrowHead != undefined)
          {
            edgeSkin.directedArrowHead = edge.directedArrowHead.toString(); 
          }          
          
          if(edge.tooltipLabel != undefined)
          {
            edgeSkin.tooltipLabel = edge.tooltipLabel.toString(); 
          }          
          
          if(edge.displayLabel != undefined)
          {
            edgeSkin.displayLabel = edge.displayLabel.toString(); 
          }          
          
          skinsManager.addEdgeSkin(edgeSkin);
        }        
        
        /** If there is no skin, we will simply use the default values. */
        startUp();

        this.removeEventListener(Event.COMPLETE, processSkinsHandler);
      }      
      
      /**
      * Select a node by its id.
      * @param id ID of the node to select. The ID of the node is its type URI.
      */
      public function selectNodeByID(id:String = null):void
      {
        try
        {
          relationBrowser.selectNodeByID(id);
          
          var n:Node = relationBrowser.getNodeByID(id);
          
          if(ExternalInterface.available)
          {
            if(n.data.props.jsReturnObject)
            {
              ExternalInterface.call("nodeAttributesValues", n.data.props.jsReturnObject);
            }
            else
            {
              ExternalInterface.call("nodeAttributesValues", []);
            }
          }
        }
        catch(e:Error)
        {
        }
      }
  
      /** Start the relation browser once everything got initialized. */
      protected function startUp():void
      {
        initDisplay();
        loadData(targetRecordURI);
        
        /** Initialize the title of the related things panel */
        if(settings.relatedThingsPanelTitle != "")
        {
          relatedThingsPanel.title = settings.relatedThingsPanelTitle;
        }
        
        /** Initialize the functions that can be called from JavaScript */
        if(ExternalInterface.available)
        {
          if(settings.displayFiltersHTML)
          {
            ExternalInterface.addCallback("hideNodeByType", hideNodeByType);
            ExternalInterface.addCallback("showNodeByType", showNodeByType);
            ExternalInterface.addCallback("hideEdgeByType", hideEdgeByType);
            ExternalInterface.addCallback("showEdgeByType", showEdgeByType);
          }
          
          if(settings.displayBreadcrumbHTML)
          {
            ExternalInterface.addCallback("selectNodeByID", selectNodeByID);
          }
        }
      }
      
      /** Note: to enable filtering, we had to fix the Tween.php class in the Flare framework */
      
      
      /**
       * Hide the edges when the explorer is re-organizing its display.
       */
      public function hideEdgesOnStageChange():void
      {
        /** Clear the previous list of removed nodes and edges */
        removedNodes = [];
        removedEdges = [];
        
        /** remove all edges of the types that have been filtered out before the stage change */
        /** First, create the list of node IDs to remove */
        var nodesToRemove:Array = [];
        
        for each(var node:Node in relationBrowser.data.nodes)
        {
          if(hiddenNodes.indexOf(node.data.type) != -1)
          {
            nodesToRemove.push(node);
            
            removedNodes.push(new Node(node.data));
          }
        }
        
        /** Then save the arcs that links to them so that we recreate them as well */
        for each(node in nodesToRemove)
        {
          for each(var edge:Edge in relationBrowser.data.edges)
          {
            if(edge.source.data.id == node.data.id ||
              edge.target.data.id == node.data.id)
            {
              removedEdges.push(new Edge(edge.source, edge.target, edge.data));
            }
          }
        }        
        
        /** Then remove the tagged edges related to the node to remove */
        for each(edge in removedEdges)
        {
          relationBrowser.data.removeEdge(edge);
        }
        
        /** Then remove the tagged nodes from the nodes list */
        for each(node in nodesToRemove)
        {
          relationBrowser.removeNode(node);
        }
        
        /** We don't update the stage here in case that we have other actions to perform */        
      }      
      
      /**
       * Hide edges by their type
       * 
       * @param edgeType The type URI of the edge to hide.
       */
      public function hideEdgeByType(edgeType:String):void
      {
        if(hiddenEdges.indexOf(edgeType) == -1)
        {
          hiddenEdges.push(edgeType);

          /** First, create the list of edge IDs to remove */
          var edgesToRemove:Array = [];

          for each(var edge:Edge in relationBrowser.data.edges)
          {
            if(hiddenEdges.indexOf(edge.data.type) != -1)
            {
              edgesToRemove.push(edge);
            }
          }
              
          for each(edge in edgesToRemove)
          {
            /** Save all the edges (not only the filtered ones) that links from/out of this node */
            for each(var e:Edge in relationBrowser.data.edges)
            {
              if(e.source.data.id == edge.source.data.id ||
                 e.target.data.id == edge.source.data.id)
              {
                /** make sure we don't add it twice */
                var found:Boolean = false;
                
                for each(var ee:Edge in removedEdges)
                {
                  if(ee.source.data.id == e.source.data.id &&
                    ee.target.data.id == e.target.data.id &&
                    ee.data.type == e.data.type)
                  {
                    found = true;
                    break;
                  }
                }
                
                if(!found)
                {
                  removedEdges.push(new Edge(edge.source, edge.target, edge.data));
                }
              }
              
              if(e.source.data.id == edge.target.data.id ||
                 e.target.data.id == edge.target.data.id)
              {
                /** make sure we don't add it twice */
                var found:Boolean = false;
                
                for each(var ee:Edge in removedEdges)
                {
                  if(ee.source.data.id == e.source.data.id &&
                     ee.target.data.id == e.target.data.id &&
                     ee.data.type == e.data.type)
                  {
                    found = true;
                    break;
                  }
                }
                
                if(!found)
                {
                  removedEdges.push(new Edge(edge.source, edge.target, edge.data));
                }
              }
            }
            
            /** Save the nodes related to this edge and remove the source/target nodes */
            if(edge.source.data.props.uri != targetRecordURI)
            {
              removedNodes.push(new Node(edge.source.data));
              relationBrowser.removeNode(edge.source);              
            }
            
            if(edge.target.data.props.uri != targetRecordURI)
            {
              removedNodes.push(new Node(edge.target.data));
              relationBrowser.removeNode(edge.target);              
            }            
          }

          /** Then remove the tagged edges related to the node to remove */
          
          for each(edge in removedEdges)
          {
            relationBrowser.data.removeEdge(edge);
          }          

          /** Then update the display */
          relationBrowser.updateDisplay();          
        }
      }      
      
      /**
       * Show edges by their type
       * 
       * @param edgeType The type URI of the edge to show.
       */
      public function showEdgeByType(edgeType:String):void
      {
        if(hiddenEdges.indexOf(edgeType) != -1)
        {
          hiddenEdges.splice(hiddenEdges.indexOf(edgeType), 1);
        }

        var nodesToRemoveFromRemovedNodes:Array = [];
        var edgesToRemoveFromRemovedEdges:Array = [];
        
        for each(var edge:Edge in removedEdges)
        {
          if(edge.data.type == edgeType)
          {
            /** Re-include the related nodes first */
            if(edge.source.data.props.uri != targetRecordURI)
            {
              relationBrowser.addNode(new NodeData(edge.source.data.id, edge.source.data.props));
              nodesToRemoveFromRemovedNodes.push(edge.source.data.id);
            }
            
            if(edge.target.data.props.uri != targetRecordURI)
            {
              relationBrowser.addNode(new NodeData(edge.target.data.id, edge.target.data.props));
              nodesToRemoveFromRemovedNodes.push(edge.target.data.id);
            }             
            
            relationBrowser.addEdge(edge.source.data.id, edge.target.data.id, edge.data);
            edgesToRemoveFromRemovedEdges.push(edge.data.id);
          } 
        }
        
        /** Remove the "removeNodes" and "removeEdges" structures */
        for each(var nodeId:String in nodesToRemoveFromRemovedNodes)
        {
          removedNodes.splice(removedNodes.indexOf(nodeId), 1);
        }

        for each(var edgeId:String in edgesToRemoveFromRemovedEdges)
        {
          removedEdges.splice(removedEdges.indexOf(edgeId), 1);
        }

        /** Then update the display */
        relationBrowser.updateDisplay();          
      }      
      
      

      /**
       * Hide nodes when the relation browser is re-organizing itself.
       */
      public function hideNodesOnStageChange():void
      {
        /** Clear the previous list of removed nodes and edges */
        removedNodes = [];
        removedEdges = [];
        
        /** remove all nodes of the types that have been filtered out before the stage change */
        /** First, create the list of node IDs to remove */
        var nodesToRemove:Array = [];
        
        for each(var node:Node in relationBrowser.data.nodes)
        {
          if(hiddenNodes.indexOf(node.data.type) != -1)
          {
            nodesToRemove.push(node);
            
            removedNodes.push(new Node(node.data));
          }
        }
        
        /** Then save the arcs that links to them so that we recreate them as well */
        for each(node in nodesToRemove)
        {
          for each(var edge:Edge in relationBrowser.data.edges)
          {
            if(edge.source.data.id == node.data.id ||
              edge.target.data.id == node.data.id)
            {
              removedEdges.push(new Edge(edge.source, edge.target, edge.data));
            }
          }
        }        
        
        /** Then remove the tagged edges related to the node to remove */
        for each(edge in removedEdges)
        {
          relationBrowser.data.removeEdge(edge);
        }
        
        /** Then remove the tagged nodes from the nodes list */
        for each(node in nodesToRemove)
        {
          relationBrowser.removeNode(node);
        }
        
        /** We don't update the stage here in case that we have other actions to perform */
      }
      
      /**
       * Hide nodes by their type
       * 
       * @param nodeType The type URI of the node to hide.
       */
      public function hideNodeByType(nodeType:String):void
      {
        if(hiddenNodes.indexOf(nodeType) == -1)
        {
          hiddenNodes.push(nodeType);
        }
        
        /** First, create the list of node IDs to remove */
        var nodesToRemove:Array = [];
        
        for each(var node:Node in relationBrowser.data.nodes)
        {
          if(hiddenNodes.indexOf(node.data.type) != -1)
          {
            nodesToRemove.push(node);
            
            removedNodes.push(new Node(node.data));
          }
        }

        /** Then save the arcs that links to them so that we recreate them as well */
        for each(node in nodesToRemove)
        {
          for each(var edge:Edge in relationBrowser.data.edges)
          {
            if(edge.source.data.id == node.data.id ||
               edge.target.data.id == node.data.id)
            {
              removedEdges.push(new Edge(edge.source, edge.target, edge.data));
            }
          }
        }        
        
        /** Then remove the tagged edges related to the node to remove */
        for each(edge in removedEdges)
        {
          relationBrowser.data.removeEdge(edge);
        }
        
        /** Then remove the tagged nodes from the nodes list */
        for each(node in nodesToRemove)
        {
          relationBrowser.removeNode(node);
        }
        
        /** Then update the display */
        relationBrowser.updateDisplay();
      }
      
      /**
       * Show nodes by their type
       * 
       * @param nodeType The type URI of the node to show.
       */
      public function showNodeByType(nodeType:String):void
      {      
        if(hiddenNodes.indexOf(nodeType) != -1)
        {
          hiddenNodes.splice(hiddenNodes.indexOf(nodeType), 1);
        }        
        
        for each(var node:Node in removedNodes)
        {
          if(node.data.type == nodeType)
          {
            relationBrowser.addNode(new NodeData(node.data.id, node.data.props));

            for each(var edge:Edge in removedEdges)
            {
              if(edge.source.data.id == node.data.id ||
                edge.target.data.id == node.data.id)
              {
                relationBrowser.addEdge(edge.source.data.id, edge.target.data.id, edge.data);
              }
            }            
          } 
        }
        
        /** Then update the display */
        relationBrowser.updateDisplay();        
      }
      
      /** 
      * Create the nodes &amp; arcs for a given conceptual view (target concept &amp; related concepts to that one).
      * The network is created by using the schema structure. 
      */
      protected function loadData(targetRecord:String):void
      {
        /** Get the record description of that node. */
        
        /** Make sure we have the proper settings to get relations betwen concepts and things */
        if(settings.conceptsDataset.length > 0 && settings.sparqlWebServiceEndpoint != "")
        {          
          /** Namespaces know by this application */
          var namespaces:Namespaces = new Namespaces();          
          
          var uri:String = namespaces.getNamespace(targetRecord);
          
          /** Update the reference to the current target record */
          targetRecordURI = targetRecord;
          
          var sparqlQuery:String =  "select ?p ?o ?so ?po ?oo ?target_s ?target_p ?target_o where\n" + 
            "{\n" +
            "  {\n" +
            "     <"+uri+"> ?p ?o. \n" +
            "  }\n" +
            "  UNION\n" +
            "  {\n" +
            "     <"+uri+"> ?pp ?so. \n" +
            "     ?so ?po ?oo. \n" +
            "  }\n" +
            "  UNION\n" +
            "  {\n" +
            "    ?target_s ?pp <"+uri+"> .\n" +
            "    ?target_s ?target_p ?target_o .\n";
          
          sparqlQuery = sparqlQuery +  "  }\n" +
            " } \n";
          
          trace("Query: \n" + sparqlQuery);
          
          /** Get related things from a SPARQL endpoint */
          var requestParameters:Object = {
            query:sparqlQuery,
            dataset:settings.conceptsDataset
          };
          
          var httpService:HTTPService = new HTTPService();     
          
          httpService.url = settings.sparqlWebServiceEndpoint;
          httpService.method = "POST";
          httpService.headers['Accept'] = "application/sparql-results+xml;q=1";
          httpService.showBusyCursor = true;
          
          httpService.addEventListener(ResultEvent.RESULT, nodeSelectionResultHandler);
          
          httpService.addEventListener(FaultEvent.FAULT, nodeSelectionFaultHandler);            
          
          httpService.send(requestParameters);          
        }
      }
      
      /** 
      * Alert the user if we got an error while getting the description of the current node from the CRUD: Read
      * web service endpoint.
      */
      private function nodeSelectionFaultHandler(event:FaultEvent):void
      {
        Alert.show(event.message.rootCause.target.data);
        
        this.removeEventListener(FaultEvent.FAULT, thingsFaultHandler);
      }
      
      /** Load the new selected node from its record description that comes from the CRUD: Read web service endpoint. */
      private function nodeSelectionResultHandler(event:ResultEvent):void 
      {     
        var uniqueNodes:Array = [];
        var uniqueEdges:Array = [];
        
        var httpService:HTTPService = event.target as HTTPService; //don't forget to stop listening. we don't want memory leaks!     
        
        var resultsetStr:String = event.message.body;
         
        resultsetStr = "<sparql>" + resultsetStr.substr((resultsetStr.indexOf(">") + 1), 
                                                      resultsetStr.length - (resultsetStr.indexOf(">") + 1));
        
        trace("SPARQL Resultset: \n" + resultsetStr);
        
        var resultsetXML:XML = XML(resultsetStr);
        
        var targetVarP:String = "p";
        var targetVarO:String = "o";
        var targetVarSO:String = "so";
        var targetVarPO:String = "po";
        var targetVarOO:String = "oo";
        var targetVarTargetS:String = "target_s";
        var targetVarTargetP:String = "target_p";
        var targetVarTargetO:String = "target_o";
        
        var links:Array = new Array();

        var recordsDescription:Array = [];
        
        var jsReturnObject:Array = [];
        
        /** Get the description of the target record */
        for each(var result:XML in resultsetXML.results.result)
        {
          /** Check if it is an object property */
          var p:String = result.binding.(@name == targetVarP).uri.toString();
          var o:String = result.binding.(@name == targetVarO).uri.toString();
          
          if(!recordsDescription.hasOwnProperty(targetRecordURI))
          {
            recordsDescription[targetRecordURI] = [];
          }
          
          if(p != "")
          {
            if(o != "")
            {
              if(recordsDescription[targetRecordURI].hasOwnProperty(p))
              {            
                /** Make sure we don't duplicate the property/value */
                var found:Boolean = false;
                for each(var obj:Object in recordsDescription[targetRecordURI][p])
                {
                  if(obj.uri == o)
                  {
                    found = true;
                    break;
                  }
                }
                
                if(!found)
                {
                  recordsDescription[targetRecordURI][p].push({"literal": "", "uri": o});
                }
              }
              else
              {
                recordsDescription[targetRecordURI][p] = [{"literal": "", "uri": o}];
              }
              
              if(settings.nodeAttributesValues.indexOf(p) != -1)
              {
                jsReturnObject.push({attribute: p, value: o});
              }
            }
            else
            {
              o = result.binding.(@name == targetVarO).literal.toString();
              
              if(recordsDescription[targetRecordURI].hasOwnProperty(p))
              {      
                /** Make sure we don't duplicate the property/value */
                var found:Boolean = false;
                for each(var obj:Object in recordsDescription[targetRecordURI][p])
                {
                  if(obj.literal == o)
                  {
                    found = true;
                    break;
                  }
                }
                
                if(!found)
                {                
                  recordsDescription[targetRecordURI][p].push({"literal": o, "uri": ""});
                }
              }
              else
              {
                recordsDescription[targetRecordURI][p] = [{"literal": o, "uri": ""}];
              }
              
              if(settings.nodeAttributesValues.indexOf(p) != -1)
              {
                jsReturnObject.push({attribute: p, value: o});
              }              
            }
          }
        }

        var jsReturnObjectLinked:Array = [];
        
        /** Get the complete description of the objects that are linked from the selected node */
        for each(var result:XML in resultsetXML.results.result)
        {
          /** Check if it is an object property */
          var so:String = result.binding.(@name == targetVarSO).uri.toString();
          var po:String = result.binding.(@name == targetVarPO).uri.toString();
          var oo:String = result.binding.(@name == targetVarOO).uri.toString();
          
          if(!recordsDescription.hasOwnProperty(so) && so != "")
          {
            recordsDescription[so] = [];
          }
          
          if(po != "")
          {
            if(oo != "")
            {
              if(recordsDescription[so].hasOwnProperty(po))
              {            
                /** Make sure we don't duplicate the property/value */
                var found:Boolean = false;
                for each(var obj:Object in recordsDescription[so][po])
                {
                  if(obj.uri == oo)
                  {
                    found = true;
                    break;
                  }
                }
                
                if(!found)
                {
                  recordsDescription[so][po].push({"literal": "", "uri": oo});
                }
              }
              else
              {
                recordsDescription[so][po] = [{"literal": "", "uri": oo}];
              }
              
              if(settings.nodeAttributesValues.indexOf(po) != -1)
              {
                if(jsReturnObjectLinked.hasOwnProperty(so))
                {                 
                  jsReturnObjectLinked[so].push({attribute: po, value: oo});
                }
                else
                {
                  jsReturnObjectLinked[so] = [{attribute: po, value: oo}];
                }
              }              
            }
            else
            {
              oo = result.binding.(@name == targetVarOO).literal.toString();
              
              if(recordsDescription[so].hasOwnProperty(po))
              {      
                /** Make sure we don't duplicate the property/value */
                var found:Boolean = false;
                for each(var obj:Object in recordsDescription[so][po])
                {
                  if(obj.literal == oo)
                  {
                    found = true;
                    break;
                  }
                }
                
                if(!found)
                {                
                  recordsDescription[so][po].push({"literal": oo, "uri": ""});
                }
              }
              else
              {
                recordsDescription[so][po] = [{"literal": oo, "uri": ""}];
              }
              
              if(settings.nodeAttributesValues.indexOf(po) != -1)
              {
                if(jsReturnObjectLinked.hasOwnProperty(so))
                {                 
                  jsReturnObjectLinked[so].push({attribute: po, value: oo});
                }
                else
                {
                  jsReturnObjectLinked[so] = [{attribute: po, value: oo}];
                }
              }                    
            }
          }
        }        
        
        /** Get the partial description of the linkback records */
        for each(var result:XML in resultsetXML.results.result)
        {
          var s:String = result.binding.(@name == targetVarTargetS).uri.toString();
          
          if(s != "" && s != targetRecordURI)
          {
            if(!recordsDescription.hasOwnProperty(s))
            {
              recordsDescription[s] = [];
            }     
            
            /** Check if it is an object property */
            var p:String = result.binding.(@name == targetVarTargetP).uri.toString();
            var o:String = result.binding.(@name == targetVarTargetO).uri.toString();
            
            if(!recordsDescription.hasOwnProperty(s))
            {
              recordsDescription[s] = [];
            }
            
            if(p != "")
            {
              if(o != "")
              {
                if(recordsDescription[s].hasOwnProperty(p))
                {            
                  /** Make sure we don't duplicate the property/value */
                  var found:Boolean = false;
                  for each(var obj:Object in recordsDescription[s][p])
                  {
                    if(obj.uri == o)
                    {
                      found = true;
                      break;
                    }
                  }
                  
                  if(!found)
                  {
                    recordsDescription[s][p].push({"literal": "", "uri": o});
                  }
                }
                else
                {
                  recordsDescription[s][p] = [{"literal": "", "uri": o}];
                }
              }
              else
              {
                o = result.binding.(@name == targetVarTargetO).literal.toString();
                
                if(recordsDescription[s].hasOwnProperty(p))
                {        
                  /** Make sure we don't duplicate the property/value */
                  var found:Boolean = false;
                  for each(var obj:Object in recordsDescription[s][p])
                  {
                    if(obj.literal == o)
                    {
                      found = true;
                      break;
                    }
                  }
                  
                  if(!found)
                  {                  
                    recordsDescription[s][p].push({"literal": o, "uri": ""});
                  }
                }
                else
                {
                  recordsDescription[s][p] = [{"literal": o, "uri": ""}];
                }
              }
            }
          }
        } 

        /** Create the structXML resultset XML document from what comes from the SPARQL endpoint */
        
        var resultsetString:String = "<?xml version=\"1.0\" encoding=\"utf-8\"?>\n" + 
            "<!DOCTYPE resultset PUBLIC \"-//Structured Dynamics LLC//Crud Read DTD 0.1//EN\" \"crud/crudRead.dtd\">\n" +
            "<resultset>\n" +
            "  <prefix entity=\"owl\" uri=\"http://www.w3.org/2002/07/owl#\"/>\n" +
            "  <prefix entity=\"rdf\" uri=\"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"/>\n" +
            "  <prefix entity=\"rdfs\" uri=\"http://www.w3.org/2000/01/rdf-schema#\"/>\n" +
            "  <prefix entity=\"wsf\" uri=\"http://purl.org/ontology/wsf#\"/>\n";
        
        for(var recordURI:String in recordsDescription)
        {
          var type:String = "http://www.w3.org/2002/07/owl#Thing";
          
          if(recordsDescription[recordURI].hasOwnProperty("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"))
          {
            type = recordsDescription[recordURI]["http://www.w3.org/1999/02/22-rdf-syntax-ns#type"][0]["uri"]
          }
          
          resultsetString += "  <subject type=\""+type+"\" " + 
                                         "uri=\""+recordURI+"\">\n";
          
          for(var propertyType:String in recordsDescription[recordURI])
          {
            for each(var value:Object in recordsDescription[recordURI][propertyType])
            {
              if(value.literal != "")
              {
                resultsetString += "    <predicate type=\""+propertyType+"\">\n";
                resultsetString += "      <object type=\"rdfs:Literal\">"+value.literal+"</object>\n";
                resultsetString += "    </predicate>\n";
              }
              else
              {
                resultsetString += "    <predicate type=\""+propertyType+"\">\n";
                resultsetString += "      <object uri=\""+value.uri+"\"/>\n";
                resultsetString += "    </predicate>\n";
              }
            }
          }
          
          resultsetString += "  </subject>\n";
        }
        
        resultsetString += "</resultset>\n";

        trace("StructXML Resultset: \n" + resultsetString);
        
        /** Check if the resultset already has records descriptions. If yes, then we merge the two resultsets. */
        if(targetRecordResultset.subjects.length > 0)
        {
          targetRecordResultsetNew = new Resultset(XML(resultsetString));
          var targetRecordResultsetOldSubjects:Array = targetRecordResultset.subjects;
          
          targetRecordResultset = new Resultset(
                                           targetRecordResultsetNew.subjects.concat(targetRecordResultsetOldSubjects));
        }
        else
        {
          targetRecordResultset = new Resultset(XML(resultsetString));
        }
        
        /** Populate the browser with the nodes and arcs */
        
        var subject:Subject = targetRecordResultset.getSubjectByURI(targetRecordURI);

        /** If the target node's type is ignore in the settings file, we don't display it */
        if(settings.ignoreNodeTypes.indexOf(subject.type) == -1 && settings.ignoreNodeUris.indexOf(subject.uri) == -1)
        {
          /** Add this new node selection to the breadcrum navigation tool */
          
          if(!(breadcrumbPath.length == 1 && 
               breadcrumbPath.getItemAt(0).uri == subject.uri))
          {
            breadcrumbPath.addItem({label: subject.getPrefLabel(this.document.generalSettings.prefLabelAttributes), 
                                    uri: subject.uri});
            
            if(ExternalInterface.available && settings.displayBreadcrumbHTML)
            {
              ExternalInterface.call("addBreadcrumb", 
                {label: subject.getPrefLabel(this.document.generalSettings.prefLabelAttributes), 
                  uri: subject.uri});
            }             
          }
                    
          /** If the node has more than one type, we choose the first one that has a node skin defined */
          var nodeType:String = subject.type;
          
          /** 
           * First check if there is a sco:relationBrowserNodeType relationship defined for this record.
           * If there is, we will use this assignation instead of the type definition of the record
           * to bind the skin to this record.
           */
          var scoType:Array = subject.getPredicateValues("http://purl.org/ontology/sco#relationBrowserNodeType");
          
          var nodeSkin:NodeSkin;
          
          if(scoType.length > 0)
          {
            nodeSkin = skinsManager.getNodeSkinByType(scoType[0].uri);
          }
          else
          {
            nodeSkin = skinsManager.getNodeSkinByType(subject.type);
          
            for each(var tt:Array in subject.getPredicateValues("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"))
            {
              nodeSkin = skinsManager.getNodeSkinByType(tt["uri"]);
              
              if(nodeSkin.defaultNode == false)
              {
                nodeType = tt["uri"];
                break;
              }
            }
          }
          
          /** 
          * If there is a node skin defined for this specific URI, we use it instead of the
          * node skin by type
          */
          
          var nodeSkinByUri:NodeSkin = skinsManager.getNodeSkinByUri(subject.uri);
          
          if(nodeSkinByUri != null)
          {
            nodeSkin = nodeSkinByUri;
          }
          
          var selectedNodeTypes:Array = [];
          
          /** Generate a node for the current type. */
          relationBrowser.addNode(new NodeData(subject.uri, 
                                               {
                                                 uri: subject.uri,
                                                 name: subject.getPrefLabel(this.document.generalSettings.prefLabelAttributes),
                                                 type: nodeType,
                                                 types: subject.getPredicateValues("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"),
                                                 skin: nodeSkin,
                                                 jsReturnObject: jsReturnObject
                                               }));
          
          for each(var nType:Array in subject.getPredicateValues("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"))
          {
            selectedNodeTypes.push(nType["uri"]);   
          }
        }
        
        /** Get the type of the predicate that links to other nodes */
        var namespaces:Namespaces = new Namespaces();          
        var relatedRecords:Array = [];
        
        for(var predicateType:String in subject.predicates)
        {
          for each(var predicate:Array in subject.predicates[predicateType])
          {
            predicateType = namespaces.getNamespace(predicateType);

            /** Make sure that it is an object property */
            if(predicate.uri != "" &&
               ((settings.linkingAttributes.length > 0 &&
                settings.linkingAttributes.indexOf(predicateType) != -1) ||
                 settings.linkingAttributes.length == 0))
            {
              /** We found an object property */
              relatedRecords.push({uri: predicate.uri, rel: predicateType});
            }
          }
        }
                    
        /** Check if the target objects (nodes) are "populated". If they are, we display them */
        /** @TODO */
        /*
          sparql
          select *
          from <...>
          {
            {
              <s1> <target-propertyA> ?o1a.
              <s1> <target-propertyB> ?o1b.
            }
            UNION
            {
              <s2> <target-propertyA> ?o2a.
              <s2> <target-propertyB> ?o2b.
            }
          }
        */
          
        /** Display the nodes and arcs from the selected node, to the other nodes */
        for each(var nodeArc:Object in relatedRecords)
        {
          /** Try to get a name of the linked node from the linkbacks from the Crud: Read web service endpoint. */
          var linkedSubject:Subject = targetRecordResultset.getSubjectByURI(nodeArc.uri);
          
          if(linkedSubject)
          {
            /** Check if the linked node has to be ignored by the settings file */
            if(settings.ignoreNodeTypes.indexOf(linkedSubject.type) == -1 && settings.ignoreNodeUris.indexOf(linkedSubject.uri) == -1)
            {
              /** Name of the linked subject node */
              var linkedSubjectName:String = "";
              
    
              linkedSubjectName = linkedSubject.getPrefLabel(this.document.generalSettings.prefLabelAttributes);
    
              /** If the node has mode than one type, we choose the first one that has a node skin defined */
              var nodeType:String = linkedSubject.type;
              
              /** 
               * First check if there is a sco:relationBrowserNodeType relationship defined for this record.
               * If there is, we will use this assignation instead of the type definition of the record
               * to bind the skin to this record.
               */
              var scoType:Array = linkedSubject.getPredicateValues("http://purl.org/ontology/sco#relationBrowserNodeType");
              
              var nodeSkin:NodeSkin;
              
              if(scoType.length > 0)
              {
                nodeSkin = skinsManager.getNodeSkinByType(scoType[0].uri);
              }
              else
              {
                nodeSkin = skinsManager.getNodeSkinByType(linkedSubject.type);
                
                for each(var lType:Array in linkedSubject.getPredicateValues("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"))
                {
                  nodeSkin = skinsManager.getNodeSkinByType(lType["uri"]);
                  
                  if(nodeSkin.defaultNode == false)
                  {
                    nodeType = lType["uri"];
                    break;
                  }
                }                
              }              
              
              /** 
               * If there is a node skin defined for this specific URI, we use it instead of the
               * node skin by type
               */
              
              var nodeSkinByUri:NodeSkin = skinsManager.getNodeSkinByUri(linkedSubject.uri);
              
              if(nodeSkinByUri != null)
              {
                nodeSkin = nodeSkinByUri;
              }              
              
              /** Generate a node for each target node. */
              relationBrowser.addNode(new NodeData(nodeArc.uri, 
                                                  {
                                                    uri: nodeArc.uri,
                                                    name: linkedSubjectName,
                                                    type: nodeType,
                                                    types: linkedSubject.getPredicateValues("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"),
                                                    skin: nodeSkin,
                                                    jsReturnObject: jsReturnObjectLinked[nodeArc.uri]
                                                  }));    
  
              for each(var nType:Array in linkedSubject.getPredicateValues("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"))
              {
                var found:Boolean = false;
                
                for each(var node:Object in uniqueNodes)
                {
                  if(node.type == nType["uri"])
                  {
                    found = true;
                  }
                }
                
                if(!found && selectedNodeTypes.indexOf(nType["uri"]) == -1)
                {
                  var nodeLabel:String = skinsManager.getNodeSkinByType(nType["uri"]).label;
                  uniqueNodes.push({type: nType["uri"], label: nodeLabel});
                }
              }
    
              /** Generate the linkage between the target node and the related node */
              relationBrowser.addEdge(subject.uri, nodeArc.uri, {
                                                                  type: nodeArc.rel, 
                                                                  skin: skinsManager.getEdgeSkinByType(nodeArc.rel)
                                                                });   
              
              var edge:EdgeSkin = skinsManager.getEdgeSkinByType(nodeArc.rel);
              
              var found:Boolean = false;
              
              for each(var e:Object in uniqueEdges)
              {
                if(e.type == nodeArc.rel)
                {
                  found = true;
                }
              }
              
              if(!found)
              {
                uniqueEdges.push({type: nodeArc.rel, label: edge.tooltipLabel });
              }      
            }
          }          
        }
        
        /** Now we have to get all the subjects that links back to the selected node */
        relatedRecords = [];
        
        for each(var remoteSubject:Subject in targetRecordResultset.subjects)
        {
          if(remoteSubject.uri != targetRecordURI)
          {
            for(var predicateType:String in remoteSubject.predicates)
            {
              for each(var predicate:Array in remoteSubject.predicates[predicateType])
              {
                predicateType = namespaces.getNamespace(predicateType);
                
                /** Make sure that it is an object property */
                if(predicate.uri != "" &&
                   predicate.uri == targetRecordURI &&
                  ((settings.linkingAttributes.length > 0 &&
                    settings.linkingAttributes.indexOf(predicateType) != -1) ||
                    settings.linkingAttributes.length == 0))
                {
                  /** We found an object property */
                  relatedRecords.push({from: remoteSubject.uri, rel: predicateType, to: predicate.uri});
                }
              }
            }
          }  
        }
     
        /** Display the nodes and arcs from other nodes, to the target node */
        for each(var nodeArc:Object in relatedRecords)
        {
          /** Try to get a name of the linked node from the linkbacks from the Crud: Read web service endpoint. */
          var linkedSubject:Subject = targetRecordResultset.getSubjectByURI(nodeArc.from);
          
          if(linkedSubject)
          {    
            /** Check if the linked node has to be ignored by the settings file */
            if(settings.ignoreNodeTypes.indexOf(linkedSubject.type) == -1 && settings.ignoreNodeUris.indexOf(linkedSubject.uri) == -1)
            {            
              /** Name of the linked subject node */
              var linkedSubjectName:String = "";
              
              linkedSubjectName = linkedSubject.getPrefLabel(this.document.generalSettings.prefLabelAttributes);
              
              /** If the node has mode than one type, we choose the first one that has a node skin defined */
              var nodeType:String = linkedSubject.type;
              
              /** 
               * First check if there is a sco:relationBrowserNodeType relationship defined for this record.
               * If there is, we will use this assignation instead of the type definition of the record
               * to bind the skin to this record.
               */
              var scoType:Array = linkedSubject.getPredicateValues("http://purl.org/ontology/sco#relationBrowserNodeType");
              
              var nodeSkin:NodeSkin;
              
              if(scoType.length > 0)
              {
                nodeSkin = skinsManager.getNodeSkinByType(scoType[0].uri);
              }
              else
              {
                nodeSkin = skinsManager.getNodeSkinByType(linkedSubject.type);
                
                for each(var lType:Array in linkedSubject.getPredicateValues("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"))
                {
                  nodeSkin = skinsManager.getNodeSkinByType(lType["uri"]);
                  
                  if(nodeSkin.defaultNode == false)
                  {
                    nodeType = lType["uri"];
                    break;
                  }
                }       
              }                            
              
              /** 
               * If there is a node skin defined for this specific URI, we use it instead of the
               * node skin by type
               */
              
              var nodeSkinByUri:NodeSkin = skinsManager.getNodeSkinByUri(linkedSubject.uri);
              
              if(nodeSkinByUri != null)
              {
                nodeSkin = nodeSkinByUri;
              }              
              
              /** Generate a node for each target node. */
              relationBrowser.addNode(new NodeData(nodeArc.from, 
                {
                  uri: nodeArc.from,
                  name: linkedSubjectName,
                  type: nodeType,
                  types: linkedSubject.getPredicateValues("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"),
                  skin: nodeSkin
                }));     
              
              
              for each(var nType:Array in linkedSubject.getPredicateValues("http://www.w3.org/1999/02/22-rdf-syntax-ns#type"))
              {
                var found:Boolean = false;
                
                for each(var node:Object in uniqueNodes)
                {
                  if(node.type == nType["uri"])
                  {
                    found = true;
                  }
                }
                
                if(!found && selectedNodeTypes.indexOf(nType["uri"]) == -1)
                {
                  var nodeLabel:String = skinsManager.getNodeSkinByType(nType["uri"]).label;
                  uniqueNodes.push({type: nType["uri"], label: nodeLabel});
                }
              }
              
              /** Generate the linkage between the target node and the related node */
              relationBrowser.addEdge(nodeArc.from, nodeArc.to, {
                type: nodeArc.rel, 
                skin: skinsManager.getEdgeSkinByType(nodeArc.rel)
              });     
              
  
              var edge:EdgeSkin = skinsManager.getEdgeSkinByType(nodeArc.rel);
              
              var found:Boolean = false;
              
              for each(var e:Object in uniqueEdges)
              {
                if(e.type == nodeArc.rel)
                {
                  found = true;
                }
              }
              
              if(!found)
              {
                uniqueEdges.push({type: nodeArc.rel, label: edge.tooltipLabel });
              }
            }
          }          
        }        
        
        /** Remove all nodes that got previously filtered out of the stage */
        hideNodesOnStageChange();
        
        /** Remove all edges that got previously filtered out of the stage */
        hideEdgesOnStageChange();
        
        /** Select the current node */
        selectNodeByID(subject.uri);         
        
        /** Update the display to shows new nodes and arcs */
        relationBrowser.updateDisplay();
        
        this.removeEventListener(ResultEvent.RESULT, thingsResultHandler);
        
        /** Update the filtering list */
        /** Display the filters */
        if(ExternalInterface.available && settings.displayFiltersHTML)
        {
          var filteredNodes:Array = [];
          var filteredEdges:Array = [];
          
          if(settings.filtersNodeTypes.length == 0)
          {
            filteredNodes = uniqueNodes;
          }
          else
          {
            for each(var uniqueNode:Object in uniqueNodes)
            {
              if(settings.filtersNodeTypes.indexOf(uniqueNode.type) != -1)
              {
                filteredNodes.push(uniqueNode);              
              }
            }
          }
          
          if(settings.filtersEdgeTypes.length == 0)
          {
            filteredEdges = uniqueEdges;
          }
          else
          {
            for each(var uniqueEdge:Object in uniqueEdges)
            {
              if(settings.filtersEdgesTypes.indexOf(uniqueEdge.type) != -1)
              {
                filteredEdges.push(uniqueEdge);              
              }
            }
          }
          
          ExternalInterface.call("populateFilterControl", filteredNodes, filteredEdges);
        }
        
        if(isLoadCompleted == false)
        {
          isLoadCompleted = true;
          
          /** Notice the webpage that the explorer is loaded */
          ExternalInterface.call("loadCompleted");
        }
      }        
  
      /** Initialize the display of the component */
      protected function initDisplay():void
      {
        if(!_initialized)
        {
          /** create the actual relation browser */
          relationBrowser = new RelationBrowser(settings);
    
          /** Check if we display information about the target concept */
          if(settings.displayConceptsInformationPanel)
          {
            infoboxPanel.visible = true;
            infoboxPanel.includeInLayout = true;
            toolsBox.visible = true;
            toolsBox.includeInLayout = true;
          }
          else
          {
            if(infoboxPanel && infoboxPanel.parent)
            {
              infoboxPanel.parent.removeChild(infoboxPanel);
            }
          }
  
          /** Check if we display potential related things */
          if(settings.displayRelatedThingsPanel)
          {
            relatedThingsPanel.visible = true;
            relatedThingsPanel.includeInLayout = true;
            toolsBox.visible = true;
            toolsBox.includeInLayout = true;
          }
          else
          {
            if(relatedThingsPanel && relatedThingsPanel.parent)
            {
              relatedThingsPanel.parent.removeChild(relatedThingsPanel);
            }
          }
          
          /** Check if we display potential related things */
          if(settings.displayBreadcrumb)
          {
            breadcrumbNavigator.visible = true;
            breadcrumbNavigator.includeInLayout = true;
          }
          else
          {
            if(breadcrumbNavigator && breadcrumbNavigator.parent)
            {
              breadcrumbNavigator.parent.removeChild(breadcrumbNavigator);
            }
          }
          
          if(!settings.displayConceptsInformationPanel && !settings.displayRelatedThingsPanel && toolsBox.parent)
          { 
            toolsBox.parent.removeChild(toolsBox);
            RelationBrowseSpriteHolder.percentWidth = 100;
            breadcrumbNavigator.percentWidth = 100;
          }
    
          /** Resize the component so that it fits the available screen estate */
          fitToCanvas();
    
          relationBrowser.addOperators(getOperators());
          relationBrowser.nodeDefaults = getNodeDefaults();
          relationBrowser.edgeDefaults = getEdgeDefaults();
          relationBrowser.sortBy = ["props.cluster"];
    
          RelationBrowseSpriteHolder.addChild(relationBrowser);
          relationBrowser.addEventListener(RelationBrowser.NODE_CLICKED, onNodeClickedHandler);
          relationBrowser.addEventListener(RelationBrowser.NODE_SELECTED, onNodeSelectedHandler);
          relationBrowser.addEventListener(RelationBrowser.NODE_SELECTION_FINISHED, onNodeSelectionFinishedHandler);
  
          RelationBrowseSpriteHolder.addEventListener(Event.RESIZE, fitToScreenHandler);
          
          _initialized = true;
        }
      }

      /** Event trigged when a resize event happen for the component. */
      private function fitToScreenHandler(event:Event):void
      {
        /** Make sure the component fit the canvas after the resize of the application */
        fitToCanvas();
      }

      /** Resize the componet to fit the available space in its parent canvas */
      private function fitToCanvas():void
      {
        /** fit in the middle of the screen */
        relationBrowser.bounds = new Rectangle(0, 0, RelationBrowseSpriteHolder.width, RelationBrowseSpriteHolder.height);
        relationBrowser.x = RelationBrowseSpriteHolder.width * .5;
        relationBrowser.y = (RelationBrowseSpriteHolder.height * .5);
        
        /** Scale if needed */
        var scaleRatio:Number = 1;
        if(RelationBrowseSpriteHolder.width < RelationBrowseSpriteHolder.height)
        {
          if(RelationBrowseSpriteHolder.width < (settings.fullSizeWidth * settings.initialScale))
          {
            scaleRatio = RelationBrowseSpriteHolder.width / (settings.fullSizeWidth * settings.initialScale);
          } 
        }
        else
        {
          if(RelationBrowseSpriteHolder.height < (settings.fullSizeHeight * settings.initialScale))
          { 
            scaleRatio = RelationBrowseSpriteHolder.height / (settings.fullSizeHeight * settings.initialScale); 
          } 
        }
        
        relationBrowser.scaleX = scaleRatio;
        relationBrowser.scaleY = scaleRatio;
      }
  
      /** Generate a default node object */
      protected function getNodeDefaults():Object
      {
        var n:Object = {
        };
  
        n.lineWidth = 2;
        n.lineColor = 0xAA666666;
        n.fillColor = 0xDD333333;
        n.shape = Shapes.CIRCLE;
        n.w = n.h = 80;
        n.edgeRadius = 55;
        n.visible = false;
        n.filters = [new DropShadowFilter(4, 45, 0, .33, 6, 6, 1, 2)];
        return n;
      }
  
      /** Generate a default arc object */
      protected function getEdgeDefaults():Object
      {
        var e:Object = {
        };
  
        e.lineWidth = 10;
        e.lineColor = 0xFF000000;
        e.lineAlpha = .5;
        e.arrowType = ArrowType.TRIANGLE;
        e.visible = false;
        e.renderer = EdgeRendererGeneric.instance;
        
        return e;
      }
  
      /** */
      public function getOperators():Vector.<Operator>
      {
        var ops:Vector.<Operator> = new Vector.<Operator>();
  
        // sample:
        // color by cluster
        var c:ColorEncoder = new ColorEncoder("props.cluster", Data.NODES, "lineColor", ScaleType.CATEGORIES,
          new ColorPalette(ColorPalette.CATEGORY_COLORS_10));
        ops.push(c);
  
        ops.push(Encoders.getScaleNodesByGraphDistanceEncoder(1, 1, .1));
        ops.push(Encoders.getScaleEdgesByGraphDistanceEncoder(4, 1, relationBrowser.showOuterEdges));
  
        return ops;
      }
  
      /** Re-generate a new view where the clicked node is the target one */
      protected function onNodeClickedHandler(event:Event):void
      {
        if(event.target.lastClickedNode)
        {
          loadData(event.target.lastClickedNode.data.id);
        }
      }
  
      /** */
      protected function onNodeSelectionFinishedHandler(event:Event):void
      {
//        for each(var n:Node in relationBrowser.data.nodes)
//        {
//          n.adjustTitleFieldSize();
//        }
      }
  
      /** Load related things &amp; concept information once the node is selected */
      private function onNodeSelectedHandler(e:Event):void
      {
        var n:Node = e.target.selectedNode;
        
        if(n)
        {
          if(settings.displayConceptsInformationPanel)
          {
            loadDetailsForNodePanel(n.data.id);
          }
          
          if(settings.displayConceptsInformationHTML)
          {
            loadDetailsForNodeHTML(n.data.id);
          }
          
          if(settings.displayRelatedThingsPanel || settings.displayRelatedThingsHTML)
          {
            loadRelatedThingsForNode(n.data.id);
          }
        }
      }

      /**
      * Load related things for a selected node in the graph. Related things are the ones that have a (normally)
      * umbel:isAbout attribute relation between the concept URI and the thing URI for a given things dataset.
      * It is displayed in a panel within the flex component.
      * 
      * @param nodeID URI of the target concept node.
      */
      private function loadRelatedThingsForNode(nodeID:String):void
      {
        /** Type of the target node */
        var subject:Subject = targetRecordResultset.getSubjectByURI(nodeID);
        
        if(subject)
        {
          /** Namespaces kow by this application */
          var namespaces:Namespaces = new Namespaces();
          
          /** Make sure we have the proper settings to get relations betwen concepts and things */
          if(settings.relatedThingsRelations.length > 0 && settings.relatedThingsLabels.length > 0 &&
             settings.thingsDataset != "" && settings.sparqlWebServiceEndpoint != "")
          {
            
            var sparqlQuery:String =  "select distinct ?thing ?prefLabel where" + 
                                      "{";
            var nb:int = 0;
            for each(var property:String in settings.relatedThingsRelations)
            {
              if(nb > 0)
              {
                sparqlQuery = sparqlQuery + "UNION";
              }
              
              sparqlQuery = sparqlQuery + " { " +
                                          "  ?thing <" + property + "> <"+namespaces.getNamespace(subject.uri)+"> ;" + 
                                          "         <" + settings.relatedThingsLabels[nb] + "> ?prefLabel ." +
                                          " } ";
              
              nb++;
            }
            sparqlQuery = sparqlQuery + "}";
            
            trace("Related Things StructXML Resultset: \n" + sparqlQuery);
            
            /** Get related things from a SPARQL endpoint */
            var requestParameters:Object = {
              query:sparqlQuery,
              dataset:settings.thingsDataset
            };
            
            var httpService:HTTPService = new HTTPService();     
            
            httpService.url = settings.sparqlWebServiceEndpoint;
            httpService.method = "POST";
            httpService.headers['Accept'] = "application/sparql-results+xml;q=1";
            httpService.showBusyCursor = true;
            
            httpService.addEventListener(ResultEvent.RESULT, thingsResultHandler);
            
            httpService.addEventListener(FaultEvent.FAULT, thingsFaultHandler);   
            
            httpService.send(requestParameters);
          }  
        }
      }
      
      /** Alert the user if we got an error while getting related things from the sparql endpoint */
      private function thingsFaultHandler(event:FaultEvent):void
      {
        Alert.show(event.message.rootCause.target.data);
        
        this.removeEventListener(FaultEvent.FAULT, thingsFaultHandler);
      }
       
      /** Load related things into the related things right side panel */
      private function thingsResultHandler(event:ResultEvent):void 
      {     
        var httpService:HTTPService = event.target as HTTPService; //don't forget to stop listening. we don't want memory leaks!     
        
        var resultsetStr:String = event.message.body;
        
        resultsetStr = "<sparql>" + resultsetStr.substr((resultsetStr.indexOf(">") + 1), resultsetStr.length - (resultsetStr.indexOf(">") + 1));
        
        var resultset:XML = XML(resultsetStr);
        
        var targetVarThing:String = "thing";
        var targetVarPrefLabel:String = "prefLabel";
        
        var links:Array = new Array();
        
        for each(var result:XML in resultset.results.result)
        {
          var thingURI:String = result.binding.(@name == targetVarThing).uri.toString();
          var thingPrefLabel:String = result.binding.(@name == targetVarPrefLabel).literal.toString();
          
          var thingPageLink:String = settings.structViewUrl + "?" +
                                     "uri=" + escape(thingURI) +
                                     "&dataset=" + escape(settings.thingsDataset);
          
          links.push({prefLabel: thingPrefLabel, link: thingPageLink});
        }
        
        /** Populate the panel list */
        if(settings.displayRelatedThingsPanel)
        {
          relatedThingsList.dataProvider = links;
          relatedThingsList.labelField = "prefLabel";
          relatedThingsList.setStyle("textAlign", "left");
        }
        
        if(settings.displayRelatedThingsHTML)
        {
          if(ExternalInterface.available)
          {
            ExternalInterface.call("displayRelatedThings", links);
          }
          else
          {
            Alert.show("Information can't be displayed in the web page because the external internace is to available" +
              " on this system.", "Error");
          } 
        }
        
        this.removeEventListener(ResultEvent.RESULT, thingsResultHandler);
      } 
      
      /** When a related  item is clicked, we open a webpage that will display that related thing */
      private function gotoThingHandler(event:ListEvent):void
      {
        var item:Object = (event.target as List).selectedItem;
        
        if(item.link)
        {
          navigateToURL(new URLRequest(item.link), settings.navigatorBehavior);
        }        
      }
      
      /** 
      * Load details related to a selected node in the panel within the flex component.
      * 
      * @nodeID ID of the node to display detailed information about.
      */
      private function loadDetailsForNodePanel(nodeID:String):void
      {
        var subject:Subject = targetRecordResultset.getSubjectByURI(nodeID);

        if(subject)
        {
          /** Remove everything from the infobox */
          infoboxBox.removeAllChildren();
          
          /** Display preferred label */
          if(subject.getPrefLabel(this.document.generalSettings.prefLabelAttributes) != "")
          {
            var hbox:HBox = new HBox();
            var nameLabel:Text = new Text();
            var name:Text = new Text();
            
            nameLabel.text = "Name:";
            nameLabel.setStyle("fontWeight", "bold");
            
            name.text = subject.getPrefLabel(this.document.generalSettings.prefLabelAttributes);
            
            hbox.styleName = "sRelationBrowserNameHBox";
            
            hbox.addChild(nameLabel);
            hbox.addChild(name);
            
            infoboxBox.addChild(hbox);
          }
  
          /** Display prefURL */
          if(subject.getPrefURL() != "")
          {
            var hbox:HBox = new HBox();
            var wikipediaLink:Label = new Label();
            
            wikipediaLink.selectable = true;
            wikipediaLink.htmlText = "<u><a href=\"" + subject.getPrefURL() +
                                     "\" target=\""+settings.navigatorBehavior+"\">Wikipedia page</a></u>";
            wikipediaLink.setStyle("fontWeight", "bold");
            
            hbox.styleName = "sRelationBrowserPrefLabelHBox";
            
            hbox.addChild(wikipediaLink);
            
            infoboxBox.addChild(hbox);
          }        
          
          /** Display description */
          if(subject.getDescription() != "")
          {
            var vbox:VBox = new VBox();
            vbox.percentHeight = 100;
            vbox.percentWidth = 100;
            vbox.styleName = "sRelationBrowserDescriptionVBox";
             
            var descriptonLabel:Text = new Text();
            var description:TextArea = new TextArea();
            
            descriptonLabel.text = "Description:";
            
            /** 
            * Check if the loaded theme define this styleName, if it does, we load it, otherwise we use
            * the default CSS for that component. 
            */
            if(StyleManager.getStyleDeclaration(".infoboxDescription"))
            {
              description.styleName = "infoboxDescription";
            }
            else
            {
              description.setStyle("textAlign", "left");
              description.setStyle("borderStyle", "none");
              description.setStyle("fontWeight", "bold");
            }
  
            description.percentHeight = 100;
            description.percentWidth = 100;
            description.text = subject.getDescription();
            description.addEventListener(TextEvent.TEXT_INPUT, PreventTextAreaInput);
  
            vbox.addChild(descriptonLabel);
            vbox.addChild(description);
            
            infoboxBox.addChild(vbox);
          }    
        }
      }
      
      /** 
       * Load details related to a selected node in the containing HTML page of this flex component.
       * Information is displayed using the ExternalInterface Javascript bridge.
       * 
       * @nodeID ID of the node to display detailed information about.
       */
      private function loadDetailsForNodeHTML(nodeID:String):void
      {
        var subject:Subject = targetRecordResultset.getSubjectByURI(nodeID);
        
        /** Populate the new details structure to send to the JS application */
        newDetails = {prefLabel: subject.getPrefLabel(), 
                      prefURL: subject.getPrefURL(), 
                      description: subject.getDescription()};
        
        if(ExternalInterface.available)
        {
          ExternalInterface.call("displayNodeDetails", newDetails);
        }
        else
        {
          Alert.show("Information can't be displayed in the web page because the external internace is to available" +
            " on this system.", "Error");
        }        
      }      
      
      private function PreventTextAreaInput(event:TextEvent):void
      {
        event.preventDefault();
      }
      
      private function breadcrumbClickHandler( event:ItemClickEvent ) : void
      {
        breadcrumbPath = breadcrumbNavigator.dataProvider;
        selectNodeByID(event.item.uri);
      } 
          
    ]]>
  </mx:Script>
  
  <mx:HBox width="100%" height="100%" styleName="sRelationBrowser"> 
    <mx:Canvas width="100%" height="100%"> 
      <mx:UIComponent id = "RelationBrowseSpriteHolder" top="20" width="80%" height="100%"/>
      <etc:BreadcrumbNavigator id="breadcrumbNavigator" dataProvider="{breadcrumbPath}" labelField="label" 
                               itemClick="breadcrumbClickHandler(event)" top="0" width="80%"
                               visible="false" includeInLayout="false" />
    </mx:Canvas>
    <mx:VBox styleName="sRelationBrowserToolsBoxVBox" id="toolsBox" height="100%" width="20%" visible="false" includeInLayout="false">
      <mx:Panel styleName="sRelationBrowserInfoboxPanel" id="infoboxPanel" height="100%" width="100%" title="Concept information"  horizontalAlign="left" textAlign="center" visible="false" includeInLayout="false">
        <mx:VBox styleName="sRelationBrowserInfoxBoxVBox" id="infoboxBox" width="100%" height="100%" >
        </mx:VBox>
      </mx:Panel>
      <mx:Panel styleName="sRelationBrowserRelatedThingsPanel" id="relatedThingsPanel" height="100%" width="100%" title="Related Things"  horizontalAlign="left" textAlign="center" visible="false" includeInLayout="false">
        <mx:List id="relatedThingsList" width="100%" height="100%" itemClick="gotoThingHandler(event)" />
      </mx:Panel>
    </mx:VBox>
  </mx:HBox>
</mx:Canvas>